import { Sidebar } from "@/components/Sidebar";

<Sidebar>
 - [anyTypeAnnotation](#anytypeannotation)
 - [argumentPlaceholder](#argumentplaceholder)
 - [arrayExpression](#arrayexpression)
 - [arrayPattern](#arraypattern)
 - [arrayTypeAnnotation](#arraytypeannotation)
 - [arrowFunctionExpression](#arrowfunctionexpression)
 - [assignmentExpression](#assignmentexpression)
 - [assignmentPattern](#assignmentpattern)
 - [awaitExpression](#awaitexpression)
 - [bigIntLiteral](#bigintliteral)
 - [binaryExpression](#binaryexpression)
 - [bindExpression](#bindexpression)
 - [blockStatement](#blockstatement)
 - [booleanLiteral](#booleanliteral)
 - [booleanLiteralTypeAnnotation](#booleanliteraltypeannotation)
 - [booleanTypeAnnotation](#booleantypeannotation)
 - [breakStatement](#breakstatement)
 - [callExpression](#callexpression)
 - [catchClause](#catchclause)
 - [classAccessorProperty](#classaccessorproperty)
 - [classBody](#classbody)
 - [classDeclaration](#classdeclaration)
 - [classExpression](#classexpression)
 - [classImplements](#classimplements)
 - [classMethod](#classmethod)
 - [classPrivateMethod](#classprivatemethod)
 - [classPrivateProperty](#classprivateproperty)
 - [classProperty](#classproperty)
 - [conditionalExpression](#conditionalexpression)
 - [continueStatement](#continuestatement)
 - [debuggerStatement](#debuggerstatement)
 - [decimalLiteral](#decimalliteral)
 - [declareClass](#declareclass)
 - [declareExportAllDeclaration](#declareexportalldeclaration)
 - [declareExportDeclaration](#declareexportdeclaration)
 - [declareFunction](#declarefunction)
 - [declareInterface](#declareinterface)
 - [declareModule](#declaremodule)
 - [declareModuleExports](#declaremoduleexports)
 - [declareOpaqueType](#declareopaquetype)
 - [declareTypeAlias](#declaretypealias)
 - [declareVariable](#declarevariable)
 - [declaredPredicate](#declaredpredicate)
 - [decorator](#decorator)
 - [directive](#directive)
 - [directiveLiteral](#directiveliteral)
 - [doExpression](#doexpression)
 - [doWhileStatement](#dowhilestatement)
 - [emptyStatement](#emptystatement)
 - [emptyTypeAnnotation](#emptytypeannotation)
 - [enumBooleanBody](#enumbooleanbody)
 - [enumBooleanMember](#enumbooleanmember)
 - [enumDeclaration](#enumdeclaration)
 - [enumDefaultedMember](#enumdefaultedmember)
 - [enumNumberBody](#enumnumberbody)
 - [enumNumberMember](#enumnumbermember)
 - [enumStringBody](#enumstringbody)
 - [enumStringMember](#enumstringmember)
 - [enumSymbolBody](#enumsymbolbody)
 - [existsTypeAnnotation](#existstypeannotation)
 - [exportAllDeclaration](#exportalldeclaration)
 - [exportDefaultDeclaration](#exportdefaultdeclaration)
 - [exportDefaultSpecifier](#exportdefaultspecifier)
 - [exportNamedDeclaration](#exportnameddeclaration)
 - [exportNamespaceSpecifier](#exportnamespacespecifier)
 - [exportSpecifier](#exportspecifier)
 - [expressionStatement](#expressionstatement)
 - [file](#file)
 - [forInStatement](#forinstatement)
 - [forOfStatement](#forofstatement)
 - [forStatement](#forstatement)
 - [functionDeclaration](#functiondeclaration)
 - [functionExpression](#functionexpression)
 - [functionTypeAnnotation](#functiontypeannotation)
 - [functionTypeParam](#functiontypeparam)
 - [genericTypeAnnotation](#generictypeannotation)
 - [identifier](#identifier)
 - [ifStatement](#ifstatement)
 - [import](#import)
 - [importAttribute](#importattribute)
 - [importDeclaration](#importdeclaration)
 - [importDefaultSpecifier](#importdefaultspecifier)
 - [importExpression](#importexpression)
 - [importNamespaceSpecifier](#importnamespacespecifier)
 - [importSpecifier](#importspecifier)
 - [indexedAccessType](#indexedaccesstype)
 - [inferredPredicate](#inferredpredicate)
 - [interfaceDeclaration](#interfacedeclaration)
 - [interfaceExtends](#interfaceextends)
 - [interfaceTypeAnnotation](#interfacetypeannotation)
 - [interpreterDirective](#interpreterdirective)
 - [intersectionTypeAnnotation](#intersectiontypeannotation)
 - [jsxAttribute](#jsxattribute)
 - [jsxClosingElement](#jsxclosingelement)
 - [jsxClosingFragment](#jsxclosingfragment)
 - [jsxElement](#jsxelement)
 - [jsxEmptyExpression](#jsxemptyexpression)
 - [jsxExpressionContainer](#jsxexpressioncontainer)
 - [jsxFragment](#jsxfragment)
 - [jsxIdentifier](#jsxidentifier)
 - [jsxMemberExpression](#jsxmemberexpression)
 - [jsxNamespacedName](#jsxnamespacedname)
 - [jsxOpeningElement](#jsxopeningelement)
 - [jsxOpeningFragment](#jsxopeningfragment)
 - [jsxSpreadAttribute](#jsxspreadattribute)
 - [jsxSpreadChild](#jsxspreadchild)
 - [jsxText](#jsxtext)
 - [labeledStatement](#labeledstatement)
 - [logicalExpression](#logicalexpression)
 - [memberExpression](#memberexpression)
 - [metaProperty](#metaproperty)
 - [mixedTypeAnnotation](#mixedtypeannotation)
 - [moduleExpression](#moduleexpression)
 - [newExpression](#newexpression)
 - [noop](#noop)
 - [nullLiteral](#nullliteral)
 - [nullLiteralTypeAnnotation](#nullliteraltypeannotation)
 - [nullableTypeAnnotation](#nullabletypeannotation)
 - [numberLiteralTypeAnnotation](#numberliteraltypeannotation)
 - [numberTypeAnnotation](#numbertypeannotation)
 - [numericLiteral](#numericliteral)
 - [objectExpression](#objectexpression)
 - [objectMethod](#objectmethod)
 - [objectPattern](#objectpattern)
 - [objectProperty](#objectproperty)
 - [objectTypeAnnotation](#objecttypeannotation)
 - [objectTypeCallProperty](#objecttypecallproperty)
 - [objectTypeIndexer](#objecttypeindexer)
 - [objectTypeInternalSlot](#objecttypeinternalslot)
 - [objectTypeProperty](#objecttypeproperty)
 - [objectTypeSpreadProperty](#objecttypespreadproperty)
 - [opaqueType](#opaquetype)
 - [optionalCallExpression](#optionalcallexpression)
 - [optionalIndexedAccessType](#optionalindexedaccesstype)
 - [optionalMemberExpression](#optionalmemberexpression)
 - [parenthesizedExpression](#parenthesizedexpression)
 - [pipelineBareFunction](#pipelinebarefunction)
 - [pipelinePrimaryTopicReference](#pipelineprimarytopicreference)
 - [pipelineTopicExpression](#pipelinetopicexpression)
 - [placeholder](#placeholder)
 - [privateName](#privatename)
 - [program](#program)
 - [qualifiedTypeIdentifier](#qualifiedtypeidentifier)
 - [recordExpression](#recordexpression)
 - [regExpLiteral](#regexpliteral)
 - [restElement](#restelement)
 - [returnStatement](#returnstatement)
 - [sequenceExpression](#sequenceexpression)
 - [spreadElement](#spreadelement)
 - [staticBlock](#staticblock)
 - [stringLiteral](#stringliteral)
 - [stringLiteralTypeAnnotation](#stringliteraltypeannotation)
 - [stringTypeAnnotation](#stringtypeannotation)
 - [super](#super)
 - [switchCase](#switchcase)
 - [switchStatement](#switchstatement)
 - [symbolTypeAnnotation](#symboltypeannotation)
 - [tsAnyKeyword](#tsanykeyword)
 - [tsArrayType](#tsarraytype)
 - [tsAsExpression](#tsasexpression)
 - [tsBigIntKeyword](#tsbigintkeyword)
 - [tsBooleanKeyword](#tsbooleankeyword)
 - [tsCallSignatureDeclaration](#tscallsignaturedeclaration)
 - [tsConditionalType](#tsconditionaltype)
 - [tsConstructSignatureDeclaration](#tsconstructsignaturedeclaration)
 - [tsConstructorType](#tsconstructortype)
 - [tsDeclareFunction](#tsdeclarefunction)
 - [tsDeclareMethod](#tsdeclaremethod)
 - [tsEnumDeclaration](#tsenumdeclaration)
 - [tsEnumMember](#tsenummember)
 - [tsExportAssignment](#tsexportassignment)
 - [tsExpressionWithTypeArguments](#tsexpressionwithtypearguments)
 - [tsExternalModuleReference](#tsexternalmodulereference)
 - [tsFunctionType](#tsfunctiontype)
 - [tsImportEqualsDeclaration](#tsimportequalsdeclaration)
 - [tsImportType](#tsimporttype)
 - [tsIndexSignature](#tsindexsignature)
 - [tsIndexedAccessType](#tsindexedaccesstype)
 - [tsInferType](#tsinfertype)
 - [tsInstantiationExpression](#tsinstantiationexpression)
 - [tsInterfaceBody](#tsinterfacebody)
 - [tsInterfaceDeclaration](#tsinterfacedeclaration)
 - [tsIntersectionType](#tsintersectiontype)
 - [tsIntrinsicKeyword](#tsintrinsickeyword)
 - [tsLiteralType](#tsliteraltype)
 - [tsMappedType](#tsmappedtype)
 - [tsMethodSignature](#tsmethodsignature)
 - [tsModuleBlock](#tsmoduleblock)
 - [tsModuleDeclaration](#tsmoduledeclaration)
 - [tsNamedTupleMember](#tsnamedtuplemember)
 - [tsNamespaceExportDeclaration](#tsnamespaceexportdeclaration)
 - [tsNeverKeyword](#tsneverkeyword)
 - [tsNonNullExpression](#tsnonnullexpression)
 - [tsNullKeyword](#tsnullkeyword)
 - [tsNumberKeyword](#tsnumberkeyword)
 - [tsObjectKeyword](#tsobjectkeyword)
 - [tsOptionalType](#tsoptionaltype)
 - [tsParameterProperty](#tsparameterproperty)
 - [tsParenthesizedType](#tsparenthesizedtype)
 - [tsPropertySignature](#tspropertysignature)
 - [tsQualifiedName](#tsqualifiedname)
 - [tsRestType](#tsresttype)
 - [tsSatisfiesExpression](#tssatisfiesexpression)
 - [tsStringKeyword](#tsstringkeyword)
 - [tsSymbolKeyword](#tssymbolkeyword)
 - [tsThisType](#tsthistype)
 - [tsTupleType](#tstupletype)
 - [tsTypeAliasDeclaration](#tstypealiasdeclaration)
 - [tsTypeAnnotation](#tstypeannotation)
 - [tsTypeAssertion](#tstypeassertion)
 - [tsTypeLiteral](#tstypeliteral)
 - [tsTypeOperator](#tstypeoperator)
 - [tsTypeParameter](#tstypeparameter)
 - [tsTypeParameterDeclaration](#tstypeparameterdeclaration)
 - [tsTypeParameterInstantiation](#tstypeparameterinstantiation)
 - [tsTypePredicate](#tstypepredicate)
 - [tsTypeQuery](#tstypequery)
 - [tsTypeReference](#tstypereference)
 - [tsUndefinedKeyword](#tsundefinedkeyword)
 - [tsUnionType](#tsuniontype)
 - [tsUnknownKeyword](#tsunknownkeyword)
 - [tsVoidKeyword](#tsvoidkeyword)
 - [taggedTemplateExpression](#taggedtemplateexpression)
 - [templateElement](#templateelement)
 - [templateLiteral](#templateliteral)
 - [thisExpression](#thisexpression)
 - [thisTypeAnnotation](#thistypeannotation)
 - [throwStatement](#throwstatement)
 - [topicReference](#topicreference)
 - [tryStatement](#trystatement)
 - [tupleExpression](#tupleexpression)
 - [tupleTypeAnnotation](#tupletypeannotation)
 - [typeAlias](#typealias)
 - [typeAnnotation](#typeannotation)
 - [typeCastExpression](#typecastexpression)
 - [typeParameter](#typeparameter)
 - [typeParameterDeclaration](#typeparameterdeclaration)
 - [typeParameterInstantiation](#typeparameterinstantiation)
 - [typeofTypeAnnotation](#typeoftypeannotation)
 - [unaryExpression](#unaryexpression)
 - [unionTypeAnnotation](#uniontypeannotation)
 - [updateExpression](#updateexpression)
 - [v8IntrinsicIdentifier](#v8intrinsicidentifier)
 - [variableDeclaration](#variabledeclaration)
 - [variableDeclarator](#variabledeclarator)
 - [variance](#variance)
 - [voidTypeAnnotation](#voidtypeannotation)
 - [whileStatement](#whilestatement)
 - [withStatement](#withstatement)
 - [yieldExpression](#yieldexpression)

</Sidebar>
import { Code } from "@/components/Code";

# @babel/types by example 

## Disclamer

This is NOT the official documentation of @bable/types, just a nicer presentation of it. It can be outdated.
If you're looking the official docs you can find them [here](https://babeljs.io/docs/babel-types).

> This module contains methods for building ASTs manually and for checking the types of AST nodes.

## Install

```shell npm2yarn
npm install --save-dev @babel/types
```

## API
### Node Builders

#### anyTypeAnnotation[#](#anytypeannotation)

<Code language="javascript">t.anyTypeAnnotation();</Code>
*AnyTypeAnnotation*
<Code file="/src/codesample/anyTypeAnnotation.js.txt" type="AnyTypeAnnotation"/>

See also `t.isAnyTypeAnnotation(node, opts)` and `t.assertAnyTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### argumentPlaceholder[#](#argumentplaceholder)

<Code language="javascript">t.argumentPlaceholder();</Code>
*ArgumentPlaceholder*
<Code file="/src/codesample/argumentPlaceholder.js.txt" type="ArgumentPlaceholder"/>

See also `t.isArgumentPlaceholder(node, opts)` and `t.assertArgumentPlaceholder(node, opts)`.

---

#### arrayExpression[#](#arrayexpression)

<Code language="javascript">t.arrayExpression(elements);</Code>
*ArrayExpression*
<Code file="/src/codesample/arrayExpression.js.txt" type="ArrayExpression"/>

See also `t.isArrayExpression(node, opts)` and `t.assertArrayExpression(node, opts)`.

AST Node `ArrayExpression` shape:
- `elements`: `Array<null | Expression | SpreadElement>` (default: `[]`)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### arrayPattern[#](#arraypattern)

<Code language="javascript">t.arrayPattern(elements);</Code>
*ArrayPattern*
<Code file="/src/codesample/arrayPattern.js.txt" type="ArrayPattern"/>

See also `t.isArrayPattern(node, opts)` and `t.assertArrayPattern(node, opts)`.

AST Node `ArrayPattern` shape:
- `elements`: `Array<null | PatternLike | LVal>` (required)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Pattern`](#pattern), [`PatternLike`](#patternlike), [`LVal`](#lval)

---

#### arrayTypeAnnotation[#](#arraytypeannotation)

<Code language="javascript">t.arrayTypeAnnotation(elementType);</Code>
*ArrayTypeAnnotation*
<Code file="/src/codesample/arrayTypeAnnotation.js.txt" type="ArrayTypeAnnotation"/>

See also `t.isArrayTypeAnnotation(node, opts)` and `t.assertArrayTypeAnnotation(node, opts)`.

AST Node `ArrayTypeAnnotation` shape:
- `elementType`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### arrowFunctionExpression[#](#arrowfunctionexpression)

<Code language="javascript">t.arrowFunctionExpression(params, body, async);</Code>
*ArrowFunctionExpression*
<Code file="/src/codesample/arrowFunctionExpression.js.txt" type="ArrowFunctionExpression"/>

See also `t.isArrowFunctionExpression(node, opts)` and `t.assertArrowFunctionExpression(node, opts)`.

AST Node `ArrowFunctionExpression` shape:
- `params`: `Array<0Identifier | 0Pattern | 0RestElement>` (required)
- `body`: `0BlockStatement | 0Expression` (required)
- `async`: `boolean` (default: `false`)
- `expression`: `boolean` (required)
- `generator`: `boolean` (default: `false`, excluded from builder function)
- `predicate`: `0DeclaredPredicate | 0InferredPredicate` (default: `null`, excluded from builder function)
- `returnType`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Function`](#function), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent), [`Expression`](#expression), [`Pureish`](#pureish)

---

#### assignmentExpression[#](#assignmentexpression)

<Code language="javascript">t.assignmentExpression(operator, left, right);</Code>
*AssignmentExpression*
<Code file="/src/codesample/assignmentExpression.js.txt" type="AssignmentExpression"/>

See also `t.isAssignmentExpression(node, opts)` and `t.assertAssignmentExpression(node, opts)`.

AST Node `AssignmentExpression` shape:
- `operator`: `string` (required)
- `left`: `0LVal | 0OptionalMemberExpression` (required)
- `right`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### assignmentPattern[#](#assignmentpattern)

<Code language="javascript">t.assignmentPattern(left, right);</Code>
*AssignmentPattern*
<Code file="/src/codesample/assignmentPattern.js.txt" type="AssignmentPattern"/>

See also `t.isAssignmentPattern(node, opts)` and `t.assertAssignmentPattern(node, opts)`.

AST Node `AssignmentPattern` shape:
- `left`: `0Identifier | 0ObjectPattern | 0ArrayPattern | 0MemberExpression | 0TSAsExpression | 0TSSatisfiesExpression | 0TSTypeAssertion | 0TSNonNullExpression` (required)
- `right`: `0Expression` (required)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Pattern`](#pattern), [`PatternLike`](#patternlike), [`LVal`](#lval)

---

#### awaitExpression[#](#awaitexpression)

<Code language="javascript">t.awaitExpression(argument);</Code>
*AwaitExpression*
<Code file="/src/codesample/awaitExpression.js.txt" type="AwaitExpression"/>

See also `t.isAwaitExpression(node, opts)` and `t.assertAwaitExpression(node, opts)`.

AST Node `AwaitExpression` shape:
- `argument`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Terminatorless`](#terminatorless)

---

#### bigIntLiteral[#](#bigintliteral)

<Code language="javascript">t.bigIntLiteral(value);</Code>
*BigIntLiteral*
<Code file="/src/codesample/bigIntLiteral.js.txt" type="BigIntLiteral"/>

See also `t.isBigIntLiteral(node, opts)` and `t.assertBigIntLiteral(node, opts)`.

AST Node `BigIntLiteral` shape:
- `value`: `string` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal), [`Immutable`](#immutable)

---

#### binaryExpression[#](#binaryexpression)

<Code language="javascript">t.binaryExpression(operator, left, right);</Code>
*BinaryExpression*
<Code file="/src/codesample/binaryExpression.js.txt" type="BinaryExpression"/>

See also `t.isBinaryExpression(node, opts)` and `t.assertBinaryExpression(node, opts)`.

AST Node `BinaryExpression` shape:
- `operator`: `"+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=" | "|>"` (required)
- `left`: `0Expression | 0PrivateName` (required)
- `right`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Binary`](#binary), [`Expression`](#expression)

---

#### bindExpression[#](#bindexpression)

<Code language="javascript">t.bindExpression(object, callee);</Code>
*BindExpression*
<Code file="/src/codesample/bindExpression.js.txt" type="BindExpression"/>

See also `t.isBindExpression(node, opts)` and `t.assertBindExpression(node, opts)`.

AST Node `BindExpression` shape:
- `object`: `0Expression` (required)
- `callee`: `0Expression` (required)

Aliases: [`Expression`](#expression)

---

#### blockStatement[#](#blockstatement)

<Code language="javascript">t.blockStatement(body, directives);</Code>
*BlockStatement*
<Code file="/src/codesample/blockStatement.js.txt" type="BlockStatement"/>

See also `t.isBlockStatement(node, opts)` and `t.assertBlockStatement(node, opts)`.

AST Node `BlockStatement` shape:
- `body`: `Array<0Statement>` (required)
- `directives`: `Array<0Directive>` (default: `[]`)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`BlockParent`](#blockparent), [`Block`](#block), [`Statement`](#statement)

---

#### booleanLiteral[#](#booleanliteral)

<Code language="javascript">t.booleanLiteral(value);</Code>
*BooleanLiteral*
<Code file="/src/codesample/booleanLiteral.js.txt" type="BooleanLiteral"/>

See also `t.isBooleanLiteral(node, opts)` and `t.assertBooleanLiteral(node, opts)`.

AST Node `BooleanLiteral` shape:
- `value`: `boolean` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal), [`Immutable`](#immutable)

---

#### booleanLiteralTypeAnnotation[#](#booleanliteraltypeannotation)

<Code language="javascript">t.booleanLiteralTypeAnnotation(value);</Code>
*BooleanLiteralTypeAnnotation*
<Code file="/src/codesample/booleanLiteralTypeAnnotation.js.txt" type="BooleanLiteralTypeAnnotation"/>

See also `t.isBooleanLiteralTypeAnnotation(node, opts)` and `t.assertBooleanLiteralTypeAnnotation(node, opts)`.

AST Node `BooleanLiteralTypeAnnotation` shape:
- `value`: `boolean` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### booleanTypeAnnotation[#](#booleantypeannotation)

<Code language="javascript">t.booleanTypeAnnotation();</Code>
*BooleanTypeAnnotation*
<Code file="/src/codesample/booleanTypeAnnotation.js.txt" type="BooleanTypeAnnotation"/>

See also `t.isBooleanTypeAnnotation(node, opts)` and `t.assertBooleanTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### breakStatement[#](#breakstatement)

<Code language="javascript">t.breakStatement(label);</Code>
*BreakStatement*
<Code file="/src/codesample/breakStatement.js.txt" type="BreakStatement"/>

See also `t.isBreakStatement(node, opts)` and `t.assertBreakStatement(node, opts)`.

AST Node `BreakStatement` shape:
- `label`: `0Identifier` (default: `null`)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Terminatorless`](#terminatorless), [`CompletionStatement`](#completionstatement)

---

#### callExpression[#](#callexpression)

<Code language="javascript">t.callExpression(callee, arguments);</Code>
*CallExpression*
<Code file="/src/codesample/callExpression.js.txt" type="CallExpression"/>

See also `t.isCallExpression(node, opts)` and `t.assertCallExpression(node, opts)`.

AST Node `CallExpression` shape:
- `callee`: `0Expression | 0Super | 0V8IntrinsicIdentifier` (required)
- `arguments`: `Array<0Expression | 0SpreadElement | 0JSXNamespacedName | 0ArgumentPlaceholder>` (required)
- `optional`: `true | false` (default: `null`, excluded from builder function)
- `typeArguments`: `0TypeParameterInstantiation` (default: `null`, excluded from builder function)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### catchClause[#](#catchclause)

<Code language="javascript">t.catchClause(param, body);</Code>
*CatchClause*
<Code file="/src/codesample/catchClause.js.txt" type="CatchClause"/>

See also `t.isCatchClause(node, opts)` and `t.assertCatchClause(node, opts)`.

AST Node `CatchClause` shape:
- `param`: `0Identifier | 0ArrayPattern | 0ObjectPattern` (default: `null`)
- `body`: `0BlockStatement` (required)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`BlockParent`](#blockparent)

---

#### classAccessorProperty[#](#classaccessorproperty)

<Code language="javascript">t.classAccessorProperty(key, value, typeAnnotation, decorators, computed, static);</Code>
*ClassAccessorProperty*
<Code file="/src/codesample/classAccessorProperty.js.txt" type="ClassAccessorProperty"/>

See also `t.isClassAccessorProperty(node, opts)` and `t.assertClassAccessorProperty(node, opts)`.

AST Node `ClassAccessorProperty` shape:
- `key`: `0Identifier | 0StringLiteral | 0NumericLiteral | 0BigIntLiteral | 0Expression | 0PrivateName` (required)
- `value`: `0Expression` (default: `null`)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`)
- `decorators`: `Array<0Decorator>` (default: `null`)
- `computed`: `boolean` (default: `false`)
- `static`: `boolean` (default: `false`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)
- `accessibility`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `definite`: `boolean` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `override`: `boolean` (default: `false`, excluded from builder function)
- `readonly`: `boolean` (default: `null`, excluded from builder function)
- `variance`: `0Variance` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Property`](#property), [`Accessor`](#accessor)

---

#### classBody[#](#classbody)

<Code language="javascript">t.classBody(body);</Code>
*ClassBody*
<Code file="/src/codesample/classBody.js.txt" type="ClassBody"/>

See also `t.isClassBody(node, opts)` and `t.assertClassBody(node, opts)`.

AST Node `ClassBody` shape:
- `body`: `Array<0ClassMethod | 0ClassPrivateMethod | 0ClassProperty | 0ClassPrivateProperty | 0ClassAccessorProperty | 0TSDeclareMethod | 0TSIndexSignature | 0StaticBlock>` (required)

Aliases: [`Standardized`](#standardized)

---

#### classDeclaration[#](#classdeclaration)

<Code language="javascript">t.classDeclaration(id, superClass, body, decorators);</Code>
*ClassDeclaration*
<Code file="/src/codesample/classDeclaration.js.txt" type="ClassDeclaration"/>

See also `t.isClassDeclaration(node, opts)` and `t.assertClassDeclaration(node, opts)`.

AST Node `ClassDeclaration` shape:
- `id`: `0Identifier` (default: `null`)
- `superClass`: `0Expression` (default: `null`)
- `body`: `0ClassBody` (required)
- `decorators`: `Array<0Decorator>` (default: `null`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `implements`: `Array<0TSExpressionWithTypeArguments | 0ClassImplements>` (default: `null`, excluded from builder function)
- `mixins`: `0InterfaceExtends` (default: `null`, excluded from builder function)
- `superTypeParameters`: `0TypeParameterInstantiation | 0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Class`](#class), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### classExpression[#](#classexpression)

<Code language="javascript">t.classExpression(id, superClass, body, decorators);</Code>
*ClassExpression*
<Code file="/src/codesample/classExpression.js.txt" type="ClassExpression"/>

See also `t.isClassExpression(node, opts)` and `t.assertClassExpression(node, opts)`.

AST Node `ClassExpression` shape:
- `id`: `0Identifier` (default: `null`)
- `superClass`: `0Expression` (default: `null`)
- `body`: `0ClassBody` (required)
- `decorators`: `Array<0Decorator>` (default: `null`)
- `implements`: `Array<0TSExpressionWithTypeArguments | 0ClassImplements>` (default: `null`, excluded from builder function)
- `mixins`: `0InterfaceExtends` (default: `null`, excluded from builder function)
- `superTypeParameters`: `0TypeParameterInstantiation | 0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Class`](#class), [`Expression`](#expression)

---

#### classImplements[#](#classimplements)

<Code language="javascript">t.classImplements(id, typeParameters);</Code>
*ClassImplements*
<Code file="/src/codesample/classImplements.js.txt" type="ClassImplements"/>

See also `t.isClassImplements(node, opts)` and `t.assertClassImplements(node, opts)`.

AST Node `ClassImplements` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterInstantiation` (default: `null`)

Aliases: [`Flow`](#flow)

---

#### classMethod[#](#classmethod)

<Code language="javascript">t.classMethod(kind, key, params, body, computed, static, generator, async);</Code>
*ClassMethod*
<Code file="/src/codesample/classMethod.js.txt" type="ClassMethod"/>

See also `t.isClassMethod(node, opts)` and `t.assertClassMethod(node, opts)`.

AST Node `ClassMethod` shape:
- `kind`: `"get" | "set" | "method" | "constructor"` (default: `'method'`)
- `key`: if computed then `Expression` else `Identifier | Literal` (required)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement | 0TSParameterProperty>` (required)
- `body`: `0BlockStatement` (required)
- `computed`: `boolean` (default: `false`)
- `static`: `boolean` (default: `false`)
- `generator`: `boolean` (default: `false`)
- `async`: `boolean` (default: `false`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)
- `access`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `accessibility`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `override`: `boolean` (default: `false`, excluded from builder function)
- `returnType`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Function`](#function), [`Scopable`](#scopable), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent), [`Method`](#method)

---

#### classPrivateMethod[#](#classprivatemethod)

<Code language="javascript">t.classPrivateMethod(kind, key, params, body, static);</Code>
*ClassPrivateMethod*
<Code file="/src/codesample/classPrivateMethod.js.txt" type="ClassPrivateMethod"/>

See also `t.isClassPrivateMethod(node, opts)` and `t.assertClassPrivateMethod(node, opts)`.

AST Node `ClassPrivateMethod` shape:
- `kind`: `"get" | "set" | "method"` (default: `'method'`)
- `key`: `0PrivateName` (required)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement | 0TSParameterProperty>` (required)
- `body`: `0BlockStatement` (required)
- `static`: `boolean` (default: `false`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)
- `access`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `accessibility`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `async`: `boolean` (default: `false`, excluded from builder function)
- `computed`: 'false' (default: `false`, excluded from builder function)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `generator`: `boolean` (default: `false`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `override`: `boolean` (default: `false`, excluded from builder function)
- `returnType`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Function`](#function), [`Scopable`](#scopable), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent), [`Method`](#method), [`Private`](#private)

---

#### classPrivateProperty[#](#classprivateproperty)

<Code language="javascript">t.classPrivateProperty(key, value, decorators, static);</Code>
*ClassPrivateProperty*
<Code file="/src/codesample/classPrivateProperty.js.txt" type="ClassPrivateProperty"/>

See also `t.isClassPrivateProperty(node, opts)` and `t.assertClassPrivateProperty(node, opts)`.

AST Node `ClassPrivateProperty` shape:
- `key`: `0PrivateName` (required)
- `value`: `0Expression` (default: `null`)
- `decorators`: `Array<0Decorator>` (default: `null`)
- `static`: `boolean` (default: `false`)
- `definite`: `boolean` (default: `null`, excluded from builder function)
- `readonly`: `boolean` (default: `null`, excluded from builder function)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `variance`: `0Variance` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Property`](#property), [`Private`](#private)

---

#### classProperty[#](#classproperty)

<Code language="javascript">t.classProperty(key, value, typeAnnotation, decorators, computed, static);</Code>
*ClassProperty*
<Code file="/src/codesample/classProperty.js.txt" type="ClassProperty"/>

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.6.0` | Supports `static` |
</details>

See also `t.isClassProperty(node, opts)` and `t.assertClassProperty(node, opts)`.

AST Node `ClassProperty` shape:
- `key`: `0Identifier | 0StringLiteral | 0NumericLiteral | 0BigIntLiteral | 0Expression` (required)
- `value`: `0Expression` (default: `null`)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`)
- `decorators`: `Array<0Decorator>` (default: `null`)
- `computed`: `boolean` (default: `false`)
- `static`: `boolean` (default: `false`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)
- `accessibility`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `definite`: `boolean` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `override`: `boolean` (default: `false`, excluded from builder function)
- `readonly`: `boolean` (default: `null`, excluded from builder function)
- `variance`: `0Variance` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Property`](#property)

---

#### conditionalExpression[#](#conditionalexpression)

<Code language="javascript">t.conditionalExpression(test, consequent, alternate);</Code>
*ConditionalExpression*
<Code file="/src/codesample/conditionalExpression.js.txt" type="ConditionalExpression"/>

See also `t.isConditionalExpression(node, opts)` and `t.assertConditionalExpression(node, opts)`.

AST Node `ConditionalExpression` shape:
- `test`: `0Expression` (required)
- `consequent`: `0Expression` (required)
- `alternate`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Conditional`](#conditional)

---

#### continueStatement[#](#continuestatement)

<Code language="javascript">t.continueStatement(label);</Code>
*ContinueStatement*
<Code file="/src/codesample/continueStatement.js.txt" type="ContinueStatement"/>

See also `t.isContinueStatement(node, opts)` and `t.assertContinueStatement(node, opts)`.

AST Node `ContinueStatement` shape:
- `label`: `0Identifier` (default: `null`)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Terminatorless`](#terminatorless), [`CompletionStatement`](#completionstatement)

---

#### debuggerStatement[#](#debuggerstatement)

<Code language="javascript">t.debuggerStatement();</Code>
*DebuggerStatement*
<Code file="/src/codesample/debuggerStatement.js.txt" type="DebuggerStatement"/>

See also `t.isDebuggerStatement(node, opts)` and `t.assertDebuggerStatement(node, opts)`.

Aliases: [`Standardized`](#standardized), [`Statement`](#statement)

---

#### decimalLiteral[#](#decimalliteral)

<Code language="javascript">t.decimalLiteral(value);</Code>
*DecimalLiteral*
<Code file="/src/codesample/decimalLiteral.js.txt" type="DecimalLiteral"/>

See also `t.isDecimalLiteral(node, opts)` and `t.assertDecimalLiteral(node, opts)`.

AST Node `DecimalLiteral` shape:
- `value`: `string` (required)

Aliases: [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal), [`Immutable`](#immutable)

---

#### declareClass[#](#declareclass)

<Code language="javascript">t.declareClass(id, typeParameters, extends, body);</Code>
*DeclareClass*
<Code file="/src/codesample/declareClass.js.txt" type="DeclareClass"/>

See also `t.isDeclareClass(node, opts)` and `t.assertDeclareClass(node, opts)`.

AST Node `DeclareClass` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `extends`: `Array<0InterfaceExtends>` (default: `null`)
- `body`: `0ObjectTypeAnnotation` (required)
- `implements`: `Array<0ClassImplements>` (default: `null`, excluded from builder function)
- `mixins`: `Array<0InterfaceExtends>` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareExportAllDeclaration[#](#declareexportalldeclaration)

<Code language="javascript">t.declareExportAllDeclaration(source);</Code>
*DeclareExportAllDeclaration*
<Code file="/src/codesample/declareExportAllDeclaration.js.txt" type="DeclareExportAllDeclaration"/>

See also `t.isDeclareExportAllDeclaration(node, opts)` and `t.assertDeclareExportAllDeclaration(node, opts)`.

AST Node `DeclareExportAllDeclaration` shape:
- `source`: `0StringLiteral` (required)
- `exportKind`: `"type" | "value"` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareExportDeclaration[#](#declareexportdeclaration)

<Code language="javascript">t.declareExportDeclaration(declaration, specifiers, source);</Code>
*DeclareExportDeclaration*
<Code file="/src/codesample/declareExportDeclaration.js.txt" type="DeclareExportDeclaration"/>

See also `t.isDeclareExportDeclaration(node, opts)` and `t.assertDeclareExportDeclaration(node, opts)`.

AST Node `DeclareExportDeclaration` shape:
- `declaration`: `0Flow` (default: `null`)
- `specifiers`: `Array<0ExportSpecifier | 0ExportNamespaceSpecifier>` (default: `null`)
- `source`: `0StringLiteral` (default: `null`)
- `default`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareFunction[#](#declarefunction)

<Code language="javascript">t.declareFunction(id);</Code>
*DeclareFunction*
<Code file="/src/codesample/declareFunction.js.txt" type="DeclareFunction"/>

See also `t.isDeclareFunction(node, opts)` and `t.assertDeclareFunction(node, opts)`.

AST Node `DeclareFunction` shape:
- `id`: `0Identifier` (required)
- `predicate`: `0DeclaredPredicate` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareInterface[#](#declareinterface)

<Code language="javascript">t.declareInterface(id, typeParameters, extends, body);</Code>
*DeclareInterface*
<Code file="/src/codesample/declareInterface.js.txt" type="DeclareInterface"/>

See also `t.isDeclareInterface(node, opts)` and `t.assertDeclareInterface(node, opts)`.

AST Node `DeclareInterface` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `extends`: `Array<0InterfaceExtends>` (default: `null`)
- `body`: `0ObjectTypeAnnotation` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareModule[#](#declaremodule)

<Code language="javascript">t.declareModule(id, body, kind);</Code>
*DeclareModule*
<Code file="/src/codesample/declareModule.js.txt" type="DeclareModule"/>

See also `t.isDeclareModule(node, opts)` and `t.assertDeclareModule(node, opts)`.

AST Node `DeclareModule` shape:
- `id`: `0Identifier | 0StringLiteral` (required)
- `body`: `0BlockStatement` (required)
- `kind`: `"CommonJS" | "ES"` (default: `null`)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareModuleExports[#](#declaremoduleexports)

<Code language="javascript">t.declareModuleExports(typeAnnotation);</Code>
*DeclareModuleExports*
<Code file="/src/codesample/declareModuleExports.js.txt" type="DeclareModuleExports"/>

See also `t.isDeclareModuleExports(node, opts)` and `t.assertDeclareModuleExports(node, opts)`.

AST Node `DeclareModuleExports` shape:
- `typeAnnotation`: `0TypeAnnotation` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareOpaqueType[#](#declareopaquetype)

<Code language="javascript">t.declareOpaqueType(id, typeParameters, supertype);</Code>
*DeclareOpaqueType*
<Code file="/src/codesample/declareOpaqueType.js.txt" type="DeclareOpaqueType"/>

See also `t.isDeclareOpaqueType(node, opts)` and `t.assertDeclareOpaqueType(node, opts)`.

AST Node `DeclareOpaqueType` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `supertype`: `0FlowType` (default: `null`)
- `impltype`: `0FlowType` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareTypeAlias[#](#declaretypealias)

<Code language="javascript">t.declareTypeAlias(id, typeParameters, right);</Code>
*DeclareTypeAlias*
<Code file="/src/codesample/declareTypeAlias.js.txt" type="DeclareTypeAlias"/>

See also `t.isDeclareTypeAlias(node, opts)` and `t.assertDeclareTypeAlias(node, opts)`.

AST Node `DeclareTypeAlias` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `right`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declareVariable[#](#declarevariable)

<Code language="javascript">t.declareVariable(id);</Code>
*DeclareVariable*
<Code file="/src/codesample/declareVariable.js.txt" type="DeclareVariable"/>

See also `t.isDeclareVariable(node, opts)` and `t.assertDeclareVariable(node, opts)`.

AST Node `DeclareVariable` shape:
- `id`: `0Identifier` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### declaredPredicate[#](#declaredpredicate)

<Code language="javascript">t.declaredPredicate(value);</Code>
*DeclaredPredicate*
<Code file="/src/codesample/declaredPredicate.js.txt" type="DeclaredPredicate"/>

See also `t.isDeclaredPredicate(node, opts)` and `t.assertDeclaredPredicate(node, opts)`.

AST Node `DeclaredPredicate` shape:
- `value`: `0Flow` (required)

Aliases: [`Flow`](#flow), [`FlowPredicate`](#flowpredicate)

---

#### decorator[#](#decorator)

<Code language="javascript">t.decorator(expression);</Code>
*Decorator*
<Code file="/src/codesample/decorator.js.txt" type="Decorator"/>

See also `t.isDecorator(node, opts)` and `t.assertDecorator(node, opts)`.

AST Node `Decorator` shape:
- `expression`: `0Expression` (required)

---

#### directive[#](#directive)

<Code language="javascript">t.directive(value);</Code>
*Directive*
<Code file="/src/codesample/directive.js.txt" type="Directive"/>

See also `t.isDirective(node, opts)` and `t.assertDirective(node, opts)`.

AST Node `Directive` shape:
- `value`: `0DirectiveLiteral` (required)

Aliases: [`Standardized`](#standardized)

---

#### directiveLiteral[#](#directiveliteral)

<Code language="javascript">t.directiveLiteral(value);</Code>
*DirectiveLiteral*
<Code file="/src/codesample/directiveLiteral.js.txt" type="DirectiveLiteral"/>

See also `t.isDirectiveLiteral(node, opts)` and `t.assertDirectiveLiteral(node, opts)`.

AST Node `DirectiveLiteral` shape:
- `value`: `string` (required)

Aliases: [`Standardized`](#standardized)

---

#### doExpression[#](#doexpression)

<Code language="javascript">t.doExpression(body, async);</Code>
*DoExpression*
<Code file="/src/codesample/doExpression.js.txt" type="DoExpression"/>

See also `t.isDoExpression(node, opts)` and `t.assertDoExpression(node, opts)`.

AST Node `DoExpression` shape:
- `body`: `0BlockStatement` (required)
- `async`: `boolean` (default: `false`)

Aliases: [`Expression`](#expression)

---

#### doWhileStatement[#](#dowhilestatement)

<Code language="javascript">t.doWhileStatement(test, body);</Code>
*DoWhileStatement*
<Code file="/src/codesample/doWhileStatement.js.txt" type="DoWhileStatement"/>

See also `t.isDoWhileStatement(node, opts)` and `t.assertDoWhileStatement(node, opts)`.

AST Node `DoWhileStatement` shape:
- `test`: `0Expression` (required)
- `body`: `0Statement` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`BlockParent`](#blockparent), [`Loop`](#loop), [`While`](#while), [`Scopable`](#scopable)

---

#### emptyStatement[#](#emptystatement)

<Code language="javascript">t.emptyStatement();</Code>
*EmptyStatement*
<Code file="/src/codesample/emptyStatement.js.txt" type="EmptyStatement"/>

See also `t.isEmptyStatement(node, opts)` and `t.assertEmptyStatement(node, opts)`.

Aliases: [`Standardized`](#standardized), [`Statement`](#statement)

---

#### emptyTypeAnnotation[#](#emptytypeannotation)

<Code language="javascript">t.emptyTypeAnnotation();</Code>
*EmptyTypeAnnotation*
<Code file="/src/codesample/emptyTypeAnnotation.js.txt" type="EmptyTypeAnnotation"/>

See also `t.isEmptyTypeAnnotation(node, opts)` and `t.assertEmptyTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### enumBooleanBody[#](#enumbooleanbody)

<Code language="javascript">t.enumBooleanBody(members);</Code>
*EnumBooleanBody*
<Code file="/src/codesample/enumBooleanBody.js.txt" type="EnumBooleanBody"/>

See also `t.isEnumBooleanBody(node, opts)` and `t.assertEnumBooleanBody(node, opts)`.

AST Node `EnumBooleanBody` shape:
- `members`: `Array<0EnumBooleanMember>` (required)
- `explicitType`: `boolean` (required)
- `hasUnknownMembers`: `boolean` (required)

Aliases: [`Flow`](#flow), [`EnumBody`](#enumbody)

---

#### enumBooleanMember[#](#enumbooleanmember)

<Code language="javascript">t.enumBooleanMember(id);</Code>
*EnumBooleanMember*
<Code file="/src/codesample/enumBooleanMember.js.txt" type="EnumBooleanMember"/>

See also `t.isEnumBooleanMember(node, opts)` and `t.assertEnumBooleanMember(node, opts)`.

AST Node `EnumBooleanMember` shape:
- `id`: `0Identifier` (required)
- `init`: `0BooleanLiteral` (required)

Aliases: [`Flow`](#flow), [`EnumMember`](#enummember)

---

#### enumDeclaration[#](#enumdeclaration)

<Code language="javascript">t.enumDeclaration(id, body);</Code>
*EnumDeclaration*
<Code file="/src/codesample/enumDeclaration.js.txt" type="EnumDeclaration"/>

See also `t.isEnumDeclaration(node, opts)` and `t.assertEnumDeclaration(node, opts)`.

AST Node `EnumDeclaration` shape:
- `id`: `0Identifier` (required)
- `body`: `0EnumBooleanBody | 0EnumNumberBody | 0EnumStringBody | 0EnumSymbolBody` (required)

Aliases: [`Flow`](#flow), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### enumDefaultedMember[#](#enumdefaultedmember)

<Code language="javascript">t.enumDefaultedMember(id);</Code>
*EnumDefaultedMember*
<Code file="/src/codesample/enumDefaultedMember.js.txt" type="EnumDefaultedMember"/>

See also `t.isEnumDefaultedMember(node, opts)` and `t.assertEnumDefaultedMember(node, opts)`.

AST Node `EnumDefaultedMember` shape:
- `id`: `0Identifier` (required)

Aliases: [`Flow`](#flow), [`EnumMember`](#enummember)

---

#### enumNumberBody[#](#enumnumberbody)

<Code language="javascript">t.enumNumberBody(members);</Code>
*EnumNumberBody*
<Code file="/src/codesample/enumNumberBody.js.txt" type="EnumNumberBody"/>

See also `t.isEnumNumberBody(node, opts)` and `t.assertEnumNumberBody(node, opts)`.

AST Node `EnumNumberBody` shape:
- `members`: `Array<0EnumNumberMember>` (required)
- `explicitType`: `boolean` (required)
- `hasUnknownMembers`: `boolean` (required)

Aliases: [`Flow`](#flow), [`EnumBody`](#enumbody)

---

#### enumNumberMember[#](#enumnumbermember)

<Code language="javascript">t.enumNumberMember(id, init);</Code>
*EnumNumberMember*
<Code file="/src/codesample/enumNumberMember.js.txt" type="EnumNumberMember"/>

See also `t.isEnumNumberMember(node, opts)` and `t.assertEnumNumberMember(node, opts)`.

AST Node `EnumNumberMember` shape:
- `id`: `0Identifier` (required)
- `init`: `0NumericLiteral` (required)

Aliases: [`Flow`](#flow), [`EnumMember`](#enummember)

---

#### enumStringBody[#](#enumstringbody)

<Code language="javascript">t.enumStringBody(members);</Code>
*EnumStringBody*
<Code file="/src/codesample/enumStringBody.js.txt" type="EnumStringBody"/>

See also `t.isEnumStringBody(node, opts)` and `t.assertEnumStringBody(node, opts)`.

AST Node `EnumStringBody` shape:
- `members`: `Array<0EnumStringMember | 0EnumDefaultedMember>` (required)
- `explicitType`: `boolean` (required)
- `hasUnknownMembers`: `boolean` (required)

Aliases: [`Flow`](#flow), [`EnumBody`](#enumbody)

---

#### enumStringMember[#](#enumstringmember)

<Code language="javascript">t.enumStringMember(id, init);</Code>
*EnumStringMember*
<Code file="/src/codesample/enumStringMember.js.txt" type="EnumStringMember"/>

See also `t.isEnumStringMember(node, opts)` and `t.assertEnumStringMember(node, opts)`.

AST Node `EnumStringMember` shape:
- `id`: `0Identifier` (required)
- `init`: `0StringLiteral` (required)

Aliases: [`Flow`](#flow), [`EnumMember`](#enummember)

---

#### enumSymbolBody[#](#enumsymbolbody)

<Code language="javascript">t.enumSymbolBody(members);</Code>
*EnumSymbolBody*
<Code file="/src/codesample/enumSymbolBody.js.txt" type="EnumSymbolBody"/>

See also `t.isEnumSymbolBody(node, opts)` and `t.assertEnumSymbolBody(node, opts)`.

AST Node `EnumSymbolBody` shape:
- `members`: `Array<0EnumDefaultedMember>` (required)
- `hasUnknownMembers`: `boolean` (required)

Aliases: [`Flow`](#flow), [`EnumBody`](#enumbody)

---

#### existsTypeAnnotation[#](#existstypeannotation)

<Code language="javascript">t.existsTypeAnnotation();</Code>
*ExistsTypeAnnotation*
<Code file="/src/codesample/existsTypeAnnotation.js.txt" type="ExistsTypeAnnotation"/>

See also `t.isExistsTypeAnnotation(node, opts)` and `t.assertExistsTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### exportAllDeclaration[#](#exportalldeclaration)

<Code language="javascript">t.exportAllDeclaration(source);</Code>
*ExportAllDeclaration*
<Code file="/src/codesample/exportAllDeclaration.js.txt" type="ExportAllDeclaration"/>

See also `t.isExportAllDeclaration(node, opts)` and `t.assertExportAllDeclaration(node, opts)`.

AST Node `ExportAllDeclaration` shape:
- `source`: `0StringLiteral` (required)
- `assertions`: `Array<0ImportAttribute>` (default: `null`, excluded from builder function)
- `attributes`: `Array<0ImportAttribute>` (default: `null`, excluded from builder function)
- `exportKind`: `"type" | "value"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Declaration`](#declaration), [`ImportOrExportDeclaration`](#importorexportdeclaration), [`ExportDeclaration`](#exportdeclaration)

---

#### exportDefaultDeclaration[#](#exportdefaultdeclaration)

<Code language="javascript">t.exportDefaultDeclaration(declaration);</Code>
*ExportDefaultDeclaration*
<Code file="/src/codesample/exportDefaultDeclaration.js.txt" type="ExportDefaultDeclaration"/>

See also `t.isExportDefaultDeclaration(node, opts)` and `t.assertExportDefaultDeclaration(node, opts)`.

AST Node `ExportDefaultDeclaration` shape:
- `declaration`: `0TSDeclareFunction | 0FunctionDeclaration | 0ClassDeclaration | 0Expression` (required)
- `exportKind`: `"value"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Declaration`](#declaration), [`ImportOrExportDeclaration`](#importorexportdeclaration), [`ExportDeclaration`](#exportdeclaration)

---

#### exportDefaultSpecifier[#](#exportdefaultspecifier)

<Code language="javascript">t.exportDefaultSpecifier(exported);</Code>
*ExportDefaultSpecifier*
<Code file="/src/codesample/exportDefaultSpecifier.js.txt" type="ExportDefaultSpecifier"/>

See also `t.isExportDefaultSpecifier(node, opts)` and `t.assertExportDefaultSpecifier(node, opts)`.

AST Node `ExportDefaultSpecifier` shape:
- `exported`: `0Identifier` (required)

Aliases: [`ModuleSpecifier`](#modulespecifier)

---

#### exportNamedDeclaration[#](#exportnameddeclaration)

<Code language="javascript">t.exportNamedDeclaration(declaration, specifiers, source);</Code>
*ExportNamedDeclaration*
<Code file="/src/codesample/exportNamedDeclaration.js.txt" type="ExportNamedDeclaration"/>

See also `t.isExportNamedDeclaration(node, opts)` and `t.assertExportNamedDeclaration(node, opts)`.

AST Node `ExportNamedDeclaration` shape:
- `declaration`: `0Declaration` (default: `null`)
- `specifiers`: `Array<0ExportSpecifier | 0ExportDefaultSpecifier | 0ExportNamespaceSpecifier>` (default: `[]`)
- `source`: `0StringLiteral` (default: `null`)
- `assertions`: `Array<0ImportAttribute>` (default: `null`, excluded from builder function)
- `attributes`: `Array<0ImportAttribute>` (default: `null`, excluded from builder function)
- `exportKind`: `"type" | "value"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Declaration`](#declaration), [`ImportOrExportDeclaration`](#importorexportdeclaration), [`ExportDeclaration`](#exportdeclaration)

---

#### exportNamespaceSpecifier[#](#exportnamespacespecifier)

<Code language="javascript">t.exportNamespaceSpecifier(exported);</Code>
*ExportNamespaceSpecifier*
<Code file="/src/codesample/exportNamespaceSpecifier.js.txt" type="ExportNamespaceSpecifier"/>

See also `t.isExportNamespaceSpecifier(node, opts)` and `t.assertExportNamespaceSpecifier(node, opts)`.

AST Node `ExportNamespaceSpecifier` shape:
- `exported`: `0Identifier` (required)

Aliases: [`Standardized`](#standardized), [`ModuleSpecifier`](#modulespecifier)

---

#### exportSpecifier[#](#exportspecifier)

<Code language="javascript">t.exportSpecifier(local, exported);</Code>
*ExportSpecifier*
<Code file="/src/codesample/exportSpecifier.js.txt" type="ExportSpecifier"/>

See also `t.isExportSpecifier(node, opts)` and `t.assertExportSpecifier(node, opts)`.

AST Node `ExportSpecifier` shape:
- `local`: `0Identifier` (required)
- `exported`: `0Identifier | 0StringLiteral` (required)
- `exportKind`: `"type" | "value"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`ModuleSpecifier`](#modulespecifier)

---

#### expressionStatement[#](#expressionstatement)

<Code language="javascript">t.expressionStatement(expression);</Code>
*ExpressionStatement*
<Code file="/src/codesample/expressionStatement.js.txt" type="ExpressionStatement"/>

See also `t.isExpressionStatement(node, opts)` and `t.assertExpressionStatement(node, opts)`.

AST Node `ExpressionStatement` shape:
- `expression`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`ExpressionWrapper`](#expressionwrapper)

---

#### file[#](#file)

<Code language="javascript">t.file(program, comments, tokens);</Code>
*File*
<Code file="/src/codesample/file.js.txt" type="File"/>

See also `t.isFile(node, opts)` and `t.assertFile(node, opts)`.

AST Node `File` shape:
- `program`: `0Program` (required)
- `comments`: `Array<0CommentBlock | 0CommentLine>` (default: `null`)
- `tokens`: `Array<any>` (default: `null`)

Aliases: [`Standardized`](#standardized)

---

#### forInStatement[#](#forinstatement)

<Code language="javascript">t.forInStatement(left, right, body);</Code>
*ForInStatement*
<Code file="/src/codesample/forInStatement.js.txt" type="ForInStatement"/>

See also `t.isForInStatement(node, opts)` and `t.assertForInStatement(node, opts)`.

AST Node `ForInStatement` shape:
- `left`: `0VariableDeclaration | 0LVal` (required)
- `right`: `0Expression` (required)
- `body`: `0Statement` (required)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Statement`](#statement), [`For`](#for), [`BlockParent`](#blockparent), [`Loop`](#loop), [`ForXStatement`](#forxstatement)

---

#### forOfStatement[#](#forofstatement)

<Code language="javascript">t.forOfStatement(left, right, body, await);</Code>
*ForOfStatement*
<Code file="/src/codesample/forOfStatement.js.txt" type="ForOfStatement"/>

See also `t.isForOfStatement(node, opts)` and `t.assertForOfStatement(node, opts)`.

AST Node `ForOfStatement` shape:
- `left`: `0VariableDeclaration | 0LVal` (required)
- `right`: `0Expression` (required)
- `body`: `0Statement` (required)
- `await`: `boolean` (default: `false`)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Statement`](#statement), [`For`](#for), [`BlockParent`](#blockparent), [`Loop`](#loop), [`ForXStatement`](#forxstatement)

---

#### forStatement[#](#forstatement)

<Code language="javascript">t.forStatement(init, test, update, body);</Code>
*ForStatement*
<Code file="/src/codesample/forStatement.js.txt" type="ForStatement"/>

See also `t.isForStatement(node, opts)` and `t.assertForStatement(node, opts)`.

AST Node `ForStatement` shape:
- `init`: `0VariableDeclaration | 0Expression` (default: `null`)
- `test`: `0Expression` (default: `null`)
- `update`: `0Expression` (default: `null`)
- `body`: `0Statement` (required)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Statement`](#statement), [`For`](#for), [`BlockParent`](#blockparent), [`Loop`](#loop)

---

#### functionDeclaration[#](#functiondeclaration)

<Code language="javascript">t.functionDeclaration(id, params, body, generator, async);</Code>
*FunctionDeclaration*
<Code file="/src/codesample/functionDeclaration.js.txt" type="FunctionDeclaration"/>

See also `t.isFunctionDeclaration(node, opts)` and `t.assertFunctionDeclaration(node, opts)`.

AST Node `FunctionDeclaration` shape:
- `id`: `0Identifier` (default: `null`)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement>` (required)
- `body`: `0BlockStatement` (required)
- `generator`: `boolean` (default: `false`)
- `async`: `boolean` (default: `false`)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `predicate`: `0DeclaredPredicate | 0InferredPredicate` (default: `null`, excluded from builder function)
- `returnType`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Function`](#function), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent), [`Statement`](#statement), [`Pureish`](#pureish), [`Declaration`](#declaration)

---

#### functionExpression[#](#functionexpression)

<Code language="javascript">t.functionExpression(id, params, body, generator, async);</Code>
*FunctionExpression*
<Code file="/src/codesample/functionExpression.js.txt" type="FunctionExpression"/>

See also `t.isFunctionExpression(node, opts)` and `t.assertFunctionExpression(node, opts)`.

AST Node `FunctionExpression` shape:
- `id`: `0Identifier` (default: `null`)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement>` (required)
- `body`: `0BlockStatement` (required)
- `generator`: `boolean` (default: `false`)
- `async`: `boolean` (default: `false`)
- `predicate`: `0DeclaredPredicate | 0InferredPredicate` (default: `null`, excluded from builder function)
- `returnType`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`Function`](#function), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent), [`Expression`](#expression), [`Pureish`](#pureish)

---

#### functionTypeAnnotation[#](#functiontypeannotation)

<Code language="javascript">t.functionTypeAnnotation(typeParameters, params, rest, returnType);</Code>
*FunctionTypeAnnotation*
<Code file="/src/codesample/functionTypeAnnotation.js.txt" type="FunctionTypeAnnotation"/>

See also `t.isFunctionTypeAnnotation(node, opts)` and `t.assertFunctionTypeAnnotation(node, opts)`.

AST Node `FunctionTypeAnnotation` shape:
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `params`: `Array<0FunctionTypeParam>` (required)
- `rest`: `0FunctionTypeParam` (default: `null`)
- `returnType`: `0FlowType` (required)
- `this`: `0FunctionTypeParam` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### functionTypeParam[#](#functiontypeparam)

<Code language="javascript">t.functionTypeParam(name, typeAnnotation);</Code>
*FunctionTypeParam*
<Code file="/src/codesample/functionTypeParam.js.txt" type="FunctionTypeParam"/>

See also `t.isFunctionTypeParam(node, opts)` and `t.assertFunctionTypeParam(node, opts)`.

AST Node `FunctionTypeParam` shape:
- `name`: `0Identifier` (default: `null`)
- `typeAnnotation`: `0FlowType` (required)
- `optional`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow)

---

#### genericTypeAnnotation[#](#generictypeannotation)

<Code language="javascript">t.genericTypeAnnotation(id, typeParameters);</Code>
*GenericTypeAnnotation*
<Code file="/src/codesample/genericTypeAnnotation.js.txt" type="GenericTypeAnnotation"/>

See also `t.isGenericTypeAnnotation(node, opts)` and `t.assertGenericTypeAnnotation(node, opts)`.

AST Node `GenericTypeAnnotation` shape:
- `id`: `0Identifier | 0QualifiedTypeIdentifier` (required)
- `typeParameters`: `0TypeParameterInstantiation` (default: `null`)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### identifier[#](#identifier)

<Code language="javascript">t.identifier(name);</Code>
*Identifier*
<Code file="/src/codesample/identifier.js.txt" type="Identifier"/>

See also `t.isIdentifier(node, opts)` and `t.assertIdentifier(node, opts)`.

AST Node `Identifier` shape:
- `name`: `string` (required)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`PatternLike`](#patternlike), [`LVal`](#lval), [`TSEntityName`](#tsentityname)

---

#### ifStatement[#](#ifstatement)

<Code language="javascript">t.ifStatement(test, consequent, alternate);</Code>
*IfStatement*
<Code file="/src/codesample/ifStatement.js.txt" type="IfStatement"/>

See also `t.isIfStatement(node, opts)` and `t.assertIfStatement(node, opts)`.

AST Node `IfStatement` shape:
- `test`: `0Expression` (required)
- `consequent`: `0Statement` (required)
- `alternate`: `0Statement` (default: `null`)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Conditional`](#conditional)

---

#### import[#](#import)

<Code language="javascript">t.import();</Code>
*Import*
<Code file="/src/codesample/import.js.txt" type="Import"/>

See also `t.isImport(node, opts)` and `t.assertImport(node, opts)`.

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### importAttribute[#](#importattribute)

<Code language="javascript">t.importAttribute(key, value);</Code>
*ImportAttribute*
<Code file="/src/codesample/importAttribute.js.txt" type="ImportAttribute"/>

See also `t.isImportAttribute(node, opts)` and `t.assertImportAttribute(node, opts)`.

AST Node `ImportAttribute` shape:
- `key`: `0Identifier | 0StringLiteral` (required)
- `value`: `0StringLiteral` (required)

---

#### importDeclaration[#](#importdeclaration)

<Code language="javascript">t.importDeclaration(specifiers, source);</Code>
*ImportDeclaration*
<Code file="/src/codesample/importDeclaration.js.txt" type="ImportDeclaration"/>

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.20.0` | Supports `module` |
</details>

See also `t.isImportDeclaration(node, opts)` and `t.assertImportDeclaration(node, opts)`.

AST Node `ImportDeclaration` shape:
- `specifiers`: `Array<0ImportSpecifier | 0ImportDefaultSpecifier | 0ImportNamespaceSpecifier>` (required)
- `source`: `0StringLiteral` (required)
- `assertions`: `Array<0ImportAttribute>` (default: `null`, excluded from builder function)
- `attributes`: `Array<0ImportAttribute>` (default: `null`, excluded from builder function)
- `importKind`: `"type" | "typeof" | "value"` (default: `null`, excluded from builder function)
- `module`: `boolean` (default: `null`, excluded from builder function)
- `phase`: `"source" | "defer"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Declaration`](#declaration), [`ImportOrExportDeclaration`](#importorexportdeclaration)

---

#### importDefaultSpecifier[#](#importdefaultspecifier)

<Code language="javascript">t.importDefaultSpecifier(local);</Code>
*ImportDefaultSpecifier*
<Code file="/src/codesample/importDefaultSpecifier.js.txt" type="ImportDefaultSpecifier"/>

See also `t.isImportDefaultSpecifier(node, opts)` and `t.assertImportDefaultSpecifier(node, opts)`.

AST Node `ImportDefaultSpecifier` shape:
- `local`: `0Identifier` (required)

Aliases: [`Standardized`](#standardized), [`ModuleSpecifier`](#modulespecifier)

---

#### importExpression[#](#importexpression)

<Code language="javascript">t.importExpression(source, options);</Code>
*ImportExpression*
<Code file="/src/codesample/importExpression.js.txt" type="ImportExpression"/>

See also `t.isImportExpression(node, opts)` and `t.assertImportExpression(node, opts)`.

AST Node `ImportExpression` shape:
- `source`: `0Expression` (required)
- `options`: `0Expression` (default: `null`)
- `phase`: `"source" | "defer"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### importNamespaceSpecifier[#](#importnamespacespecifier)

<Code language="javascript">t.importNamespaceSpecifier(local);</Code>
*ImportNamespaceSpecifier*
<Code file="/src/codesample/importNamespaceSpecifier.js.txt" type="ImportNamespaceSpecifier"/>

See also `t.isImportNamespaceSpecifier(node, opts)` and `t.assertImportNamespaceSpecifier(node, opts)`.

AST Node `ImportNamespaceSpecifier` shape:
- `local`: `0Identifier` (required)

Aliases: [`Standardized`](#standardized), [`ModuleSpecifier`](#modulespecifier)

---

#### importSpecifier[#](#importspecifier)

<Code language="javascript">t.importSpecifier(local, imported);</Code>
*ImportSpecifier*
<Code file="/src/codesample/importSpecifier.js.txt" type="ImportSpecifier"/>

See also `t.isImportSpecifier(node, opts)` and `t.assertImportSpecifier(node, opts)`.

AST Node `ImportSpecifier` shape:
- `local`: `0Identifier` (required)
- `imported`: `0Identifier | 0StringLiteral` (required)
- `importKind`: `"type" | "typeof" | "value"` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`ModuleSpecifier`](#modulespecifier)

---

#### indexedAccessType[#](#indexedaccesstype)

<Code language="javascript">t.indexedAccessType(objectType, indexType);</Code>
*IndexedAccessType*
<Code file="/src/codesample/indexedAccessType.js.txt" type="IndexedAccessType"/>

See also `t.isIndexedAccessType(node, opts)` and `t.assertIndexedAccessType(node, opts)`.

AST Node `IndexedAccessType` shape:
- `objectType`: `0FlowType` (required)
- `indexType`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### inferredPredicate[#](#inferredpredicate)

<Code language="javascript">t.inferredPredicate();</Code>
*InferredPredicate*
<Code file="/src/codesample/inferredPredicate.js.txt" type="InferredPredicate"/>

See also `t.isInferredPredicate(node, opts)` and `t.assertInferredPredicate(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowPredicate`](#flowpredicate)

---

#### interfaceDeclaration[#](#interfacedeclaration)

<Code language="javascript">t.interfaceDeclaration(id, typeParameters, extends, body);</Code>
*InterfaceDeclaration*
<Code file="/src/codesample/interfaceDeclaration.js.txt" type="InterfaceDeclaration"/>

See also `t.isInterfaceDeclaration(node, opts)` and `t.assertInterfaceDeclaration(node, opts)`.

AST Node `InterfaceDeclaration` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `extends`: `Array<0InterfaceExtends>` (default: `null`)
- `body`: `0ObjectTypeAnnotation` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### interfaceExtends[#](#interfaceextends)

<Code language="javascript">t.interfaceExtends(id, typeParameters);</Code>
*InterfaceExtends*
<Code file="/src/codesample/interfaceExtends.js.txt" type="InterfaceExtends"/>

See also `t.isInterfaceExtends(node, opts)` and `t.assertInterfaceExtends(node, opts)`.

AST Node `InterfaceExtends` shape:
- `id`: `0Identifier | 0QualifiedTypeIdentifier` (required)
- `typeParameters`: `0TypeParameterInstantiation` (default: `null`)

Aliases: [`Flow`](#flow)

---

#### interfaceTypeAnnotation[#](#interfacetypeannotation)

<Code language="javascript">t.interfaceTypeAnnotation(extends, body);</Code>
*InterfaceTypeAnnotation*
<Code file="/src/codesample/interfaceTypeAnnotation.js.txt" type="InterfaceTypeAnnotation"/>

See also `t.isInterfaceTypeAnnotation(node, opts)` and `t.assertInterfaceTypeAnnotation(node, opts)`.

AST Node `InterfaceTypeAnnotation` shape:
- `extends`: `Array<0InterfaceExtends>` (default: `null`)
- `body`: `0ObjectTypeAnnotation` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### interpreterDirective[#](#interpreterdirective)

<Code language="javascript">t.interpreterDirective(value);</Code>
*InterpreterDirective*
<Code file="/src/codesample/interpreterDirective.js.txt" type="InterpreterDirective"/>

See also `t.isInterpreterDirective(node, opts)` and `t.assertInterpreterDirective(node, opts)`.

AST Node `InterpreterDirective` shape:
- `value`: `string` (required)

Aliases: [`Standardized`](#standardized)

---

#### intersectionTypeAnnotation[#](#intersectiontypeannotation)

<Code language="javascript">t.intersectionTypeAnnotation(types);</Code>
*IntersectionTypeAnnotation*
<Code file="/src/codesample/intersectionTypeAnnotation.js.txt" type="IntersectionTypeAnnotation"/>

See also `t.isIntersectionTypeAnnotation(node, opts)` and `t.assertIntersectionTypeAnnotation(node, opts)`.

AST Node `IntersectionTypeAnnotation` shape:
- `types`: `Array<0FlowType>` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### jsxAttribute[#](#jsxattribute)

<Code language="javascript">t.jsxAttribute(name, value);</Code>
*JSXAttribute*
<Code file="/src/codesample/jsxAttribute.js.txt" type="JSXAttribute"/>

See also `t.isJSXAttribute(node, opts)` and `t.assertJSXAttribute(node, opts)`.

AST Node `JSXAttribute` shape:
- `name`: `0JSXIdentifier | 0JSXNamespacedName` (required)
- `value`: `0JSXElement | 0JSXFragment | 0StringLiteral | 0JSXExpressionContainer` (default: `null`)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxClosingElement[#](#jsxclosingelement)

<Code language="javascript">t.jsxClosingElement(name);</Code>
*JSXClosingElement*
<Code file="/src/codesample/jsxClosingElement.js.txt" type="JSXClosingElement"/>

See also `t.isJSXClosingElement(node, opts)` and `t.assertJSXClosingElement(node, opts)`.

AST Node `JSXClosingElement` shape:
- `name`: `0JSXIdentifier | 0JSXMemberExpression | 0JSXNamespacedName` (required)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxClosingFragment[#](#jsxclosingfragment)

<Code language="javascript">t.jsxClosingFragment();</Code>
*JSXClosingFragment*
<Code file="/src/codesample/jsxClosingFragment.js.txt" type="JSXClosingFragment"/>

See also `t.isJSXClosingFragment(node, opts)` and `t.assertJSXClosingFragment(node, opts)`.

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxElement[#](#jsxelement)

<Code language="javascript">t.jsxElement(openingElement, closingElement, children, selfClosing);</Code>
*JSXElement*
<Code file="/src/codesample/jsxElement.js.txt" type="JSXElement"/>

See also `t.isJSXElement(node, opts)` and `t.assertJSXElement(node, opts)`.

AST Node `JSXElement` shape:
- `openingElement`: `0JSXOpeningElement` (required)
- `closingElement`: `0JSXClosingElement` (default: `null`)
- `children`: `Array<0JSXText | 0JSXExpressionContainer | 0JSXSpreadChild | 0JSXElement | 0JSXFragment>` (required)
- `selfClosing`: `boolean` (default: `null`)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable), [`Expression`](#expression)

---

#### jsxEmptyExpression[#](#jsxemptyexpression)

<Code language="javascript">t.jsxEmptyExpression();</Code>
*JSXEmptyExpression*
<Code file="/src/codesample/jsxEmptyExpression.js.txt" type="JSXEmptyExpression"/>

See also `t.isJSXEmptyExpression(node, opts)` and `t.assertJSXEmptyExpression(node, opts)`.

Aliases: [`JSX`](#jsx)

---

#### jsxExpressionContainer[#](#jsxexpressioncontainer)

<Code language="javascript">t.jsxExpressionContainer(expression);</Code>
*JSXExpressionContainer*
<Code file="/src/codesample/jsxExpressionContainer.js.txt" type="JSXExpressionContainer"/>

See also `t.isJSXExpressionContainer(node, opts)` and `t.assertJSXExpressionContainer(node, opts)`.

AST Node `JSXExpressionContainer` shape:
- `expression`: `0Expression | 0JSXEmptyExpression` (required)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxFragment[#](#jsxfragment)

<Code language="javascript">t.jsxFragment(openingFragment, closingFragment, children);</Code>
*JSXFragment*
<Code file="/src/codesample/jsxFragment.js.txt" type="JSXFragment"/>

See also `t.isJSXFragment(node, opts)` and `t.assertJSXFragment(node, opts)`.

AST Node `JSXFragment` shape:
- `openingFragment`: `0JSXOpeningFragment` (required)
- `closingFragment`: `0JSXClosingFragment` (required)
- `children`: `Array<0JSXText | 0JSXExpressionContainer | 0JSXSpreadChild | 0JSXElement | 0JSXFragment>` (required)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable), [`Expression`](#expression)

---

#### jsxIdentifier[#](#jsxidentifier)

<Code language="javascript">t.jsxIdentifier(name);</Code>
*JSXIdentifier*
<Code file="/src/codesample/jsxIdentifier.js.txt" type="JSXIdentifier"/>

See also `t.isJSXIdentifier(node, opts)` and `t.assertJSXIdentifier(node, opts)`.

AST Node `JSXIdentifier` shape:
- `name`: `string` (required)

Aliases: [`JSX`](#jsx)

---

#### jsxMemberExpression[#](#jsxmemberexpression)

<Code language="javascript">t.jsxMemberExpression(object, property);</Code>
*JSXMemberExpression*
<Code file="/src/codesample/jsxMemberExpression.js.txt" type="JSXMemberExpression"/>

See also `t.isJSXMemberExpression(node, opts)` and `t.assertJSXMemberExpression(node, opts)`.

AST Node `JSXMemberExpression` shape:
- `object`: `0JSXMemberExpression | 0JSXIdentifier` (required)
- `property`: `0JSXIdentifier` (required)

Aliases: [`JSX`](#jsx)

---

#### jsxNamespacedName[#](#jsxnamespacedname)

<Code language="javascript">t.jsxNamespacedName(namespace, name);</Code>
*JSXNamespacedName*
<Code file="/src/codesample/jsxNamespacedName.js.txt" type="JSXNamespacedName"/>

See also `t.isJSXNamespacedName(node, opts)` and `t.assertJSXNamespacedName(node, opts)`.

AST Node `JSXNamespacedName` shape:
- `namespace`: `0JSXIdentifier` (required)
- `name`: `0JSXIdentifier` (required)

Aliases: [`JSX`](#jsx)

---

#### jsxOpeningElement[#](#jsxopeningelement)

<Code language="javascript">t.jsxOpeningElement(name, attributes, selfClosing);</Code>
*JSXOpeningElement*
<Code file="/src/codesample/jsxOpeningElement.js.txt" type="JSXOpeningElement"/>

See also `t.isJSXOpeningElement(node, opts)` and `t.assertJSXOpeningElement(node, opts)`.

AST Node `JSXOpeningElement` shape:
- `name`: `0JSXIdentifier | 0JSXMemberExpression | 0JSXNamespacedName` (required)
- `attributes`: `Array<0JSXAttribute | 0JSXSpreadAttribute>` (required)
- `selfClosing`: `boolean` (default: `false`)
- `typeParameters`: `0TypeParameterInstantiation | 0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxOpeningFragment[#](#jsxopeningfragment)

<Code language="javascript">t.jsxOpeningFragment();</Code>
*JSXOpeningFragment*
<Code file="/src/codesample/jsxOpeningFragment.js.txt" type="JSXOpeningFragment"/>

See also `t.isJSXOpeningFragment(node, opts)` and `t.assertJSXOpeningFragment(node, opts)`.

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxSpreadAttribute[#](#jsxspreadattribute)

<Code language="javascript">t.jsxSpreadAttribute(argument);</Code>
*JSXSpreadAttribute*
<Code file="/src/codesample/jsxSpreadAttribute.js.txt" type="JSXSpreadAttribute"/>

See also `t.isJSXSpreadAttribute(node, opts)` and `t.assertJSXSpreadAttribute(node, opts)`.

AST Node `JSXSpreadAttribute` shape:
- `argument`: `0Expression` (required)

Aliases: [`JSX`](#jsx)

---

#### jsxSpreadChild[#](#jsxspreadchild)

<Code language="javascript">t.jsxSpreadChild(expression);</Code>
*JSXSpreadChild*
<Code file="/src/codesample/jsxSpreadChild.js.txt" type="JSXSpreadChild"/>

See also `t.isJSXSpreadChild(node, opts)` and `t.assertJSXSpreadChild(node, opts)`.

AST Node `JSXSpreadChild` shape:
- `expression`: `0Expression` (required)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### jsxText[#](#jsxtext)

<Code language="javascript">t.jsxText(value);</Code>
*JSXText*
<Code file="/src/codesample/jsxText.js.txt" type="JSXText"/>

See also `t.isJSXText(node, opts)` and `t.assertJSXText(node, opts)`.

AST Node `JSXText` shape:
- `value`: `string` (required)

Aliases: [`JSX`](#jsx), [`Immutable`](#immutable)

---

#### labeledStatement[#](#labeledstatement)

<Code language="javascript">t.labeledStatement(label, body);</Code>
*LabeledStatement*
<Code file="/src/codesample/labeledStatement.js.txt" type="LabeledStatement"/>

See also `t.isLabeledStatement(node, opts)` and `t.assertLabeledStatement(node, opts)`.

AST Node `LabeledStatement` shape:
- `label`: `0Identifier` (required)
- `body`: `0Statement` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement)

---

#### logicalExpression[#](#logicalexpression)

<Code language="javascript">t.logicalExpression(operator, left, right);</Code>
*LogicalExpression*
<Code file="/src/codesample/logicalExpression.js.txt" type="LogicalExpression"/>

See also `t.isLogicalExpression(node, opts)` and `t.assertLogicalExpression(node, opts)`.

AST Node `LogicalExpression` shape:
- `operator`: `"||" | "&&" | "??"` (required)
- `left`: `0Expression` (required)
- `right`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Binary`](#binary), [`Expression`](#expression)

---

#### memberExpression[#](#memberexpression)

<Code language="javascript">t.memberExpression(object, property, computed, optional);</Code>
*MemberExpression*
<Code file="/src/codesample/memberExpression.js.txt" type="MemberExpression"/>

See also `t.isMemberExpression(node, opts)` and `t.assertMemberExpression(node, opts)`.

AST Node `MemberExpression` shape:
- `object`: `0Expression | 0Super` (required)
- `property`: if computed then `Expression` else `Identifier` (required)
- `computed`: `boolean` (default: `false`)
- `optional`: `true | false` (default: `null`)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`LVal`](#lval)

---

#### metaProperty[#](#metaproperty)

<Code language="javascript">t.metaProperty(meta, property);</Code>
*MetaProperty*
<Code file="/src/codesample/metaProperty.js.txt" type="MetaProperty"/>

See also `t.isMetaProperty(node, opts)` and `t.assertMetaProperty(node, opts)`.

AST Node `MetaProperty` shape:
- `meta`: `0Identifier` (required)
- `property`: `0Identifier` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### mixedTypeAnnotation[#](#mixedtypeannotation)

<Code language="javascript">t.mixedTypeAnnotation();</Code>
*MixedTypeAnnotation*
<Code file="/src/codesample/mixedTypeAnnotation.js.txt" type="MixedTypeAnnotation"/>

See also `t.isMixedTypeAnnotation(node, opts)` and `t.assertMixedTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### moduleExpression[#](#moduleexpression)

<Code language="javascript">t.moduleExpression(body);</Code>
*ModuleExpression*
<Code file="/src/codesample/moduleExpression.js.txt" type="ModuleExpression"/>

See also `t.isModuleExpression(node, opts)` and `t.assertModuleExpression(node, opts)`.

AST Node `ModuleExpression` shape:
- `body`: `0Program` (required)

Aliases: [`Expression`](#expression)

---

#### newExpression[#](#newexpression)

<Code language="javascript">t.newExpression(callee, arguments);</Code>
*NewExpression*
<Code file="/src/codesample/newExpression.js.txt" type="NewExpression"/>

See also `t.isNewExpression(node, opts)` and `t.assertNewExpression(node, opts)`.

AST Node `NewExpression` shape:
- `callee`: `0Expression | 0Super | 0V8IntrinsicIdentifier` (required)
- `arguments`: `Array<0Expression | 0SpreadElement | 0JSXNamespacedName | 0ArgumentPlaceholder>` (required)
- `optional`: `true | false` (default: `null`, excluded from builder function)
- `typeArguments`: `0TypeParameterInstantiation` (default: `null`, excluded from builder function)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### noop[#](#noop)

<Code language="javascript">t.noop();</Code>
*Noop*
<Code file="/src/codesample/noop.js.txt" type="Noop"/>

See also `t.isNoop(node, opts)` and `t.assertNoop(node, opts)`.

Aliases: [`Miscellaneous`](#miscellaneous)

---

#### nullLiteral[#](#nullliteral)

<Code language="javascript">t.nullLiteral();</Code>
*NullLiteral*
<Code file="/src/codesample/nullLiteral.js.txt" type="NullLiteral"/>

See also `t.isNullLiteral(node, opts)` and `t.assertNullLiteral(node, opts)`.

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal), [`Immutable`](#immutable)

---

#### nullLiteralTypeAnnotation[#](#nullliteraltypeannotation)

<Code language="javascript">t.nullLiteralTypeAnnotation();</Code>
*NullLiteralTypeAnnotation*
<Code file="/src/codesample/nullLiteralTypeAnnotation.js.txt" type="NullLiteralTypeAnnotation"/>

See also `t.isNullLiteralTypeAnnotation(node, opts)` and `t.assertNullLiteralTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### nullableTypeAnnotation[#](#nullabletypeannotation)

<Code language="javascript">t.nullableTypeAnnotation(typeAnnotation);</Code>
*NullableTypeAnnotation*
<Code file="/src/codesample/nullableTypeAnnotation.js.txt" type="NullableTypeAnnotation"/>

See also `t.isNullableTypeAnnotation(node, opts)` and `t.assertNullableTypeAnnotation(node, opts)`.

AST Node `NullableTypeAnnotation` shape:
- `typeAnnotation`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### numberLiteralTypeAnnotation[#](#numberliteraltypeannotation)

<Code language="javascript">t.numberLiteralTypeAnnotation(value);</Code>
*NumberLiteralTypeAnnotation*
<Code file="/src/codesample/numberLiteralTypeAnnotation.js.txt" type="NumberLiteralTypeAnnotation"/>

See also `t.isNumberLiteralTypeAnnotation(node, opts)` and `t.assertNumberLiteralTypeAnnotation(node, opts)`.

AST Node `NumberLiteralTypeAnnotation` shape:
- `value`: `number` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### numberTypeAnnotation[#](#numbertypeannotation)

<Code language="javascript">t.numberTypeAnnotation();</Code>
*NumberTypeAnnotation*
<Code file="/src/codesample/numberTypeAnnotation.js.txt" type="NumberTypeAnnotation"/>

See also `t.isNumberTypeAnnotation(node, opts)` and `t.assertNumberTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### numericLiteral[#](#numericliteral)

<Code language="javascript">t.numericLiteral(value);</Code>
*NumericLiteral*
<Code file="/src/codesample/numericLiteral.js.txt" type="NumericLiteral"/>

See also `t.isNumericLiteral(node, opts)` and `t.assertNumericLiteral(node, opts)`.

AST Node `NumericLiteral` shape:
- `value`: a non-negative finite `number` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal), [`Immutable`](#immutable)

---

#### objectExpression[#](#objectexpression)

<Code language="javascript">t.objectExpression(properties);</Code>
*ObjectExpression*
<Code file="/src/codesample/objectExpression.js.txt" type="ObjectExpression"/>

See also `t.isObjectExpression(node, opts)` and `t.assertObjectExpression(node, opts)`.

AST Node `ObjectExpression` shape:
- `properties`: `Array<0ObjectMethod | 0ObjectProperty | 0SpreadElement>` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### objectMethod[#](#objectmethod)

<Code language="javascript">t.objectMethod(kind, key, params, body, computed, generator, async);</Code>
*ObjectMethod*
<Code file="/src/codesample/objectMethod.js.txt" type="ObjectMethod"/>

See also `t.isObjectMethod(node, opts)` and `t.assertObjectMethod(node, opts)`.

AST Node `ObjectMethod` shape:
- `kind`: `"method" | "get" | "set"` (default: `'method'`)
- `key`: if computed then `Expression` else `Identifier | Literal` (required)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement>` (required)
- `body`: `0BlockStatement` (required)
- `computed`: `boolean` (default: `false`)
- `generator`: `boolean` (default: `false`)
- `async`: `boolean` (default: `false`)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `returnType`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)
- `typeParameters`: `0TypeParameterDeclaration | 0TSTypeParameterDeclaration | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`UserWhitespacable`](#userwhitespacable), [`Function`](#function), [`Scopable`](#scopable), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent), [`Method`](#method), [`ObjectMember`](#objectmember)

---

#### objectPattern[#](#objectpattern)

<Code language="javascript">t.objectPattern(properties);</Code>
*ObjectPattern*
<Code file="/src/codesample/objectPattern.js.txt" type="ObjectPattern"/>

See also `t.isObjectPattern(node, opts)` and `t.assertObjectPattern(node, opts)`.

AST Node `ObjectPattern` shape:
- `properties`: `Array<0RestElement | 0ObjectProperty>` (required)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Pattern`](#pattern), [`PatternLike`](#patternlike), [`LVal`](#lval)

---

#### objectProperty[#](#objectproperty)

<Code language="javascript">t.objectProperty(key, value, computed, shorthand, decorators);</Code>
*ObjectProperty*
<Code file="/src/codesample/objectProperty.js.txt" type="ObjectProperty"/>

See also `t.isObjectProperty(node, opts)` and `t.assertObjectProperty(node, opts)`.

AST Node `ObjectProperty` shape:
- `key`: if computed then `Expression` else `Identifier | Literal` (required)
- `value`: `0Expression | 0PatternLike` (required)
- `computed`: `boolean` (default: `false`)
- `shorthand`: `boolean` (default: `false`)
- `decorators`: `Array<0Decorator>` (default: `null`)

Aliases: [`Standardized`](#standardized), [`UserWhitespacable`](#userwhitespacable), [`Property`](#property), [`ObjectMember`](#objectmember)

---

#### objectTypeAnnotation[#](#objecttypeannotation)

<Code language="javascript">t.objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact);</Code>
*ObjectTypeAnnotation*
<Code file="/src/codesample/objectTypeAnnotation.js.txt" type="ObjectTypeAnnotation"/>

See also `t.isObjectTypeAnnotation(node, opts)` and `t.assertObjectTypeAnnotation(node, opts)`.

AST Node `ObjectTypeAnnotation` shape:
- `properties`: `Array<0ObjectTypeProperty | 0ObjectTypeSpreadProperty>` (required)
- `indexers`: `Array<0ObjectTypeIndexer>` (default: `[]`)
- `callProperties`: `Array<0ObjectTypeCallProperty>` (default: `[]`)
- `internalSlots`: `Array<0ObjectTypeInternalSlot>` (default: `[]`)
- `exact`: `boolean` (default: `false`)
- `inexact`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### objectTypeCallProperty[#](#objecttypecallproperty)

<Code language="javascript">t.objectTypeCallProperty(value);</Code>
*ObjectTypeCallProperty*
<Code file="/src/codesample/objectTypeCallProperty.js.txt" type="ObjectTypeCallProperty"/>

See also `t.isObjectTypeCallProperty(node, opts)` and `t.assertObjectTypeCallProperty(node, opts)`.

AST Node `ObjectTypeCallProperty` shape:
- `value`: `0FlowType` (required)
- `static`: `boolean` (required)

Aliases: [`Flow`](#flow), [`UserWhitespacable`](#userwhitespacable)

---

#### objectTypeIndexer[#](#objecttypeindexer)

<Code language="javascript">t.objectTypeIndexer(id, key, value, variance);</Code>
*ObjectTypeIndexer*
<Code file="/src/codesample/objectTypeIndexer.js.txt" type="ObjectTypeIndexer"/>

See also `t.isObjectTypeIndexer(node, opts)` and `t.assertObjectTypeIndexer(node, opts)`.

AST Node `ObjectTypeIndexer` shape:
- `id`: `0Identifier` (default: `null`)
- `key`: `0FlowType` (required)
- `value`: `0FlowType` (required)
- `variance`: `0Variance` (default: `null`)
- `static`: `boolean` (required)

Aliases: [`Flow`](#flow), [`UserWhitespacable`](#userwhitespacable)

---

#### objectTypeInternalSlot[#](#objecttypeinternalslot)

<Code language="javascript">t.objectTypeInternalSlot(id, value, optional, static, method);</Code>
*ObjectTypeInternalSlot*
<Code file="/src/codesample/objectTypeInternalSlot.js.txt" type="ObjectTypeInternalSlot"/>

See also `t.isObjectTypeInternalSlot(node, opts)` and `t.assertObjectTypeInternalSlot(node, opts)`.

AST Node `ObjectTypeInternalSlot` shape:
- `id`: `0Identifier` (required)
- `value`: `0FlowType` (required)
- `optional`: `boolean` (required)
- `static`: `boolean` (required)
- `method`: `boolean` (required)

Aliases: [`Flow`](#flow), [`UserWhitespacable`](#userwhitespacable)

---

#### objectTypeProperty[#](#objecttypeproperty)

<Code language="javascript">t.objectTypeProperty(key, value, variance);</Code>
*ObjectTypeProperty*
<Code file="/src/codesample/objectTypeProperty.js.txt" type="ObjectTypeProperty"/>

See also `t.isObjectTypeProperty(node, opts)` and `t.assertObjectTypeProperty(node, opts)`.

AST Node `ObjectTypeProperty` shape:
- `key`: `0Identifier | 0StringLiteral` (required)
- `value`: `0FlowType` (required)
- `variance`: `0Variance` (default: `null`)
- `kind`: `"init" | "get" | "set"` (required)
- `method`: `boolean` (required)
- `optional`: `boolean` (required)
- `proto`: `boolean` (required)
- `static`: `boolean` (required)

Aliases: [`Flow`](#flow), [`UserWhitespacable`](#userwhitespacable)

---

#### objectTypeSpreadProperty[#](#objecttypespreadproperty)

<Code language="javascript">t.objectTypeSpreadProperty(argument);</Code>
*ObjectTypeSpreadProperty*
<Code file="/src/codesample/objectTypeSpreadProperty.js.txt" type="ObjectTypeSpreadProperty"/>

See also `t.isObjectTypeSpreadProperty(node, opts)` and `t.assertObjectTypeSpreadProperty(node, opts)`.

AST Node `ObjectTypeSpreadProperty` shape:
- `argument`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`UserWhitespacable`](#userwhitespacable)

---

#### opaqueType[#](#opaquetype)

<Code language="javascript">t.opaqueType(id, typeParameters, supertype, impltype);</Code>
*OpaqueType*
<Code file="/src/codesample/opaqueType.js.txt" type="OpaqueType"/>

See also `t.isOpaqueType(node, opts)` and `t.assertOpaqueType(node, opts)`.

AST Node `OpaqueType` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `supertype`: `0FlowType` (default: `null`)
- `impltype`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### optionalCallExpression[#](#optionalcallexpression)

<Code language="javascript">t.optionalCallExpression(callee, arguments, optional);</Code>
*OptionalCallExpression*
<Code file="/src/codesample/optionalCallExpression.js.txt" type="OptionalCallExpression"/>

See also `t.isOptionalCallExpression(node, opts)` and `t.assertOptionalCallExpression(node, opts)`.

AST Node `OptionalCallExpression` shape:
- `callee`: `0Expression` (required)
- `arguments`: `Array<0Expression | 0SpreadElement | 0JSXNamespacedName | 0ArgumentPlaceholder>` (required)
- `optional`: `boolean` (required)
- `typeArguments`: `0TypeParameterInstantiation` (default: `null`, excluded from builder function)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### optionalIndexedAccessType[#](#optionalindexedaccesstype)

<Code language="javascript">t.optionalIndexedAccessType(objectType, indexType);</Code>
*OptionalIndexedAccessType*
<Code file="/src/codesample/optionalIndexedAccessType.js.txt" type="OptionalIndexedAccessType"/>

See also `t.isOptionalIndexedAccessType(node, opts)` and `t.assertOptionalIndexedAccessType(node, opts)`.

AST Node `OptionalIndexedAccessType` shape:
- `objectType`: `0FlowType` (required)
- `indexType`: `0FlowType` (required)
- `optional`: `boolean` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### optionalMemberExpression[#](#optionalmemberexpression)

<Code language="javascript">t.optionalMemberExpression(object, property, computed, optional);</Code>
*OptionalMemberExpression*
<Code file="/src/codesample/optionalMemberExpression.js.txt" type="OptionalMemberExpression"/>

See also `t.isOptionalMemberExpression(node, opts)` and `t.assertOptionalMemberExpression(node, opts)`.

AST Node `OptionalMemberExpression` shape:
- `object`: `0Expression` (required)
- `property`: `0Expression | 0Identifier` (required)
- `computed`: `boolean` (default: `false`)
- `optional`: `boolean` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### parenthesizedExpression[#](#parenthesizedexpression)

<Code language="javascript">t.parenthesizedExpression(expression);</Code>
*ParenthesizedExpression*
<Code file="/src/codesample/parenthesizedExpression.js.txt" type="ParenthesizedExpression"/>

See also `t.isParenthesizedExpression(node, opts)` and `t.assertParenthesizedExpression(node, opts)`.

AST Node `ParenthesizedExpression` shape:
- `expression`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`ExpressionWrapper`](#expressionwrapper)

---

#### pipelineBareFunction[#](#pipelinebarefunction)

<Code language="javascript">t.pipelineBareFunction(callee);</Code>
*PipelineBareFunction*
<Code file="/src/codesample/pipelineBareFunction.js.txt" type="PipelineBareFunction"/>

See also `t.isPipelineBareFunction(node, opts)` and `t.assertPipelineBareFunction(node, opts)`.

AST Node `PipelineBareFunction` shape:
- `callee`: `0Expression` (required)

Aliases: [`Expression`](#expression)

---

#### pipelinePrimaryTopicReference[#](#pipelineprimarytopicreference)

<Code language="javascript">t.pipelinePrimaryTopicReference();</Code>
*PipelinePrimaryTopicReference*
<Code file="/src/codesample/pipelinePrimaryTopicReference.js.txt" type="PipelinePrimaryTopicReference"/>

See also `t.isPipelinePrimaryTopicReference(node, opts)` and `t.assertPipelinePrimaryTopicReference(node, opts)`.

Aliases: [`Expression`](#expression)

---

#### pipelineTopicExpression[#](#pipelinetopicexpression)

<Code language="javascript">t.pipelineTopicExpression(expression);</Code>
*PipelineTopicExpression*
<Code file="/src/codesample/pipelineTopicExpression.js.txt" type="PipelineTopicExpression"/>

See also `t.isPipelineTopicExpression(node, opts)` and `t.assertPipelineTopicExpression(node, opts)`.

AST Node `PipelineTopicExpression` shape:
- `expression`: `0Expression` (required)

Aliases: [`Expression`](#expression)

---

#### placeholder[#](#placeholder)

<Code language="javascript">t.placeholder(expectedNode, name);</Code>
*Placeholder*
<Code file="/src/codesample/placeholder.js.txt" type="Placeholder"/>

See also `t.isPlaceholder(node, opts)` and `t.assertPlaceholder(node, opts)`.

AST Node `Placeholder` shape:
- `expectedNode`: `"Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern"` (required)
- `name`: `0Identifier` (required)

Aliases: [`Miscellaneous`](#miscellaneous)

---

#### privateName[#](#privatename)

<Code language="javascript">t.privateName(id);</Code>
*PrivateName*
<Code file="/src/codesample/privateName.js.txt" type="PrivateName"/>

See also `t.isPrivateName(node, opts)` and `t.assertPrivateName(node, opts)`.

AST Node `PrivateName` shape:
- `id`: `0Identifier` (required)

Aliases: [`Standardized`](#standardized), [`Private`](#private)

---

#### program[#](#program)

<Code language="javascript">t.program(body, directives, sourceType, interpreter);</Code>
*Program*
<Code file="/src/codesample/program.js.txt" type="Program"/>

See also `t.isProgram(node, opts)` and `t.assertProgram(node, opts)`.

AST Node `Program` shape:
- `body`: `Array<0Statement>` (required)
- `directives`: `Array<0Directive>` (default: `[]`)
- `sourceType`: `"script" | "module"` (default: `'script'`)
- `interpreter`: `0InterpreterDirective` (default: `null`)
- `sourceFile`: `string` (required)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`BlockParent`](#blockparent), [`Block`](#block)

---

#### qualifiedTypeIdentifier[#](#qualifiedtypeidentifier)

<Code language="javascript">t.qualifiedTypeIdentifier(id, qualification);</Code>
*QualifiedTypeIdentifier*
<Code file="/src/codesample/qualifiedTypeIdentifier.js.txt" type="QualifiedTypeIdentifier"/>

See also `t.isQualifiedTypeIdentifier(node, opts)` and `t.assertQualifiedTypeIdentifier(node, opts)`.

AST Node `QualifiedTypeIdentifier` shape:
- `id`: `0Identifier` (required)
- `qualification`: `0Identifier | 0QualifiedTypeIdentifier` (required)

Aliases: [`Flow`](#flow)

---

#### recordExpression[#](#recordexpression)

<Code language="javascript">t.recordExpression(properties);</Code>
*RecordExpression*
<Code file="/src/codesample/recordExpression.js.txt" type="RecordExpression"/>

See also `t.isRecordExpression(node, opts)` and `t.assertRecordExpression(node, opts)`.

AST Node `RecordExpression` shape:
- `properties`: `Array<0ObjectProperty | 0SpreadElement>` (required)

Aliases: [`Expression`](#expression)

---

#### regExpLiteral[#](#regexpliteral)

<Code language="javascript">t.regExpLiteral(pattern, flags);</Code>
*RegExpLiteral*
<Code file="/src/codesample/regExpLiteral.js.txt" type="RegExpLiteral"/>

See also `t.isRegExpLiteral(node, opts)` and `t.assertRegExpLiteral(node, opts)`.

AST Node `RegExpLiteral` shape:
- `pattern`: `string` (required)
- `flags`: `string` (default: `''`)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal)

---

#### restElement[#](#restelement)

<Code language="javascript">t.restElement(argument);</Code>
*RestElement*
<Code file="/src/codesample/restElement.js.txt" type="RestElement"/>

See also `t.isRestElement(node, opts)` and `t.assertRestElement(node, opts)`.

AST Node `RestElement` shape:
- `argument`: `0LVal` (required)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `typeAnnotation`: `0TypeAnnotation | 0TSTypeAnnotation | 0Noop` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`LVal`](#lval), [`PatternLike`](#patternlike)

---

#### returnStatement[#](#returnstatement)

<Code language="javascript">t.returnStatement(argument);</Code>
*ReturnStatement*
<Code file="/src/codesample/returnStatement.js.txt" type="ReturnStatement"/>

See also `t.isReturnStatement(node, opts)` and `t.assertReturnStatement(node, opts)`.

AST Node `ReturnStatement` shape:
- `argument`: `0Expression` (default: `null`)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Terminatorless`](#terminatorless), [`CompletionStatement`](#completionstatement)

---

#### sequenceExpression[#](#sequenceexpression)

<Code language="javascript">t.sequenceExpression(expressions);</Code>
*SequenceExpression*
<Code file="/src/codesample/sequenceExpression.js.txt" type="SequenceExpression"/>

See also `t.isSequenceExpression(node, opts)` and `t.assertSequenceExpression(node, opts)`.

AST Node `SequenceExpression` shape:
- `expressions`: `Array<0Expression>` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### spreadElement[#](#spreadelement)

<Code language="javascript">t.spreadElement(argument);</Code>
*SpreadElement*
<Code file="/src/codesample/spreadElement.js.txt" type="SpreadElement"/>

See also `t.isSpreadElement(node, opts)` and `t.assertSpreadElement(node, opts)`.

AST Node `SpreadElement` shape:
- `argument`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`UnaryLike`](#unarylike)

---

#### staticBlock[#](#staticblock)

<Code language="javascript">t.staticBlock(body);</Code>
*StaticBlock*
<Code file="/src/codesample/staticBlock.js.txt" type="StaticBlock"/>

See also `t.isStaticBlock(node, opts)` and `t.assertStaticBlock(node, opts)`.

AST Node `StaticBlock` shape:
- `body`: `Array<0Statement>` (required)

Aliases: [`Standardized`](#standardized), [`Scopable`](#scopable), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent)

---

#### stringLiteral[#](#stringliteral)

<Code language="javascript">t.stringLiteral(value);</Code>
*StringLiteral*
<Code file="/src/codesample/stringLiteral.js.txt" type="StringLiteral"/>

See also `t.isStringLiteral(node, opts)` and `t.assertStringLiteral(node, opts)`.

AST Node `StringLiteral` shape:
- `value`: `string` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Pureish`](#pureish), [`Literal`](#literal), [`Immutable`](#immutable)

---

#### stringLiteralTypeAnnotation[#](#stringliteraltypeannotation)

<Code language="javascript">t.stringLiteralTypeAnnotation(value);</Code>
*StringLiteralTypeAnnotation*
<Code file="/src/codesample/stringLiteralTypeAnnotation.js.txt" type="StringLiteralTypeAnnotation"/>

See also `t.isStringLiteralTypeAnnotation(node, opts)` and `t.assertStringLiteralTypeAnnotation(node, opts)`.

AST Node `StringLiteralTypeAnnotation` shape:
- `value`: `string` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### stringTypeAnnotation[#](#stringtypeannotation)

<Code language="javascript">t.stringTypeAnnotation();</Code>
*StringTypeAnnotation*
<Code file="/src/codesample/stringTypeAnnotation.js.txt" type="StringTypeAnnotation"/>

See also `t.isStringTypeAnnotation(node, opts)` and `t.assertStringTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### super[#](#super)

<Code language="javascript">t.super();</Code>
*Super*
<Code file="/src/codesample/super.js.txt" type="Super"/>

See also `t.isSuper(node, opts)` and `t.assertSuper(node, opts)`.

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### switchCase[#](#switchcase)

<Code language="javascript">t.switchCase(test, consequent);</Code>
*SwitchCase*
<Code file="/src/codesample/switchCase.js.txt" type="SwitchCase"/>

See also `t.isSwitchCase(node, opts)` and `t.assertSwitchCase(node, opts)`.

AST Node `SwitchCase` shape:
- `test`: `0Expression` (default: `null`)
- `consequent`: `Array<0Statement>` (required)

Aliases: [`Standardized`](#standardized)

---

#### switchStatement[#](#switchstatement)

<Code language="javascript">t.switchStatement(discriminant, cases);</Code>
*SwitchStatement*
<Code file="/src/codesample/switchStatement.js.txt" type="SwitchStatement"/>

See also `t.isSwitchStatement(node, opts)` and `t.assertSwitchStatement(node, opts)`.

AST Node `SwitchStatement` shape:
- `discriminant`: `0Expression` (required)
- `cases`: `Array<0SwitchCase>` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`BlockParent`](#blockparent), [`Scopable`](#scopable)

---

#### symbolTypeAnnotation[#](#symboltypeannotation)

<Code language="javascript">t.symbolTypeAnnotation();</Code>
*SymbolTypeAnnotation*
<Code file="/src/codesample/symbolTypeAnnotation.js.txt" type="SymbolTypeAnnotation"/>

See also `t.isSymbolTypeAnnotation(node, opts)` and `t.assertSymbolTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### tsAnyKeyword[#](#tsanykeyword)

<Code language="javascript">t.tsAnyKeyword();</Code>
*TSAnyKeyword*
<Code file="/src/codesample/tsAnyKeyword.js.txt" type="TSAnyKeyword"/>

See also `t.isTSAnyKeyword(node, opts)` and `t.assertTSAnyKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsArrayType[#](#tsarraytype)

<Code language="javascript">t.tsArrayType(elementType);</Code>
*TSArrayType*
<Code file="/src/codesample/tsArrayType.js.txt" type="TSArrayType"/>

See also `t.isTSArrayType(node, opts)` and `t.assertTSArrayType(node, opts)`.

AST Node `TSArrayType` shape:
- `elementType`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsAsExpression[#](#tsasexpression)

<Code language="javascript">t.tsAsExpression(expression, typeAnnotation);</Code>
*TSAsExpression*
<Code file="/src/codesample/tsAsExpression.js.txt" type="TSAsExpression"/>

See also `t.isTSAsExpression(node, opts)` and `t.assertTSAsExpression(node, opts)`.

AST Node `TSAsExpression` shape:
- `expression`: `0Expression` (required)
- `typeAnnotation`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`Expression`](#expression), [`LVal`](#lval), [`PatternLike`](#patternlike)

---

#### tsBigIntKeyword[#](#tsbigintkeyword)

<Code language="javascript">t.tsBigIntKeyword();</Code>
*TSBigIntKeyword*
<Code file="/src/codesample/tsBigIntKeyword.js.txt" type="TSBigIntKeyword"/>

See also `t.isTSBigIntKeyword(node, opts)` and `t.assertTSBigIntKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsBooleanKeyword[#](#tsbooleankeyword)

<Code language="javascript">t.tsBooleanKeyword();</Code>
*TSBooleanKeyword*
<Code file="/src/codesample/tsBooleanKeyword.js.txt" type="TSBooleanKeyword"/>

See also `t.isTSBooleanKeyword(node, opts)` and `t.assertTSBooleanKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsCallSignatureDeclaration[#](#tscallsignaturedeclaration)

<Code language="javascript">t.tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation);</Code>
*TSCallSignatureDeclaration*
<Code file="/src/codesample/tsCallSignatureDeclaration.js.txt" type="TSCallSignatureDeclaration"/>

See also `t.isTSCallSignatureDeclaration(node, opts)` and `t.assertTSCallSignatureDeclaration(node, opts)`.

AST Node `TSCallSignatureDeclaration` shape:
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `parameters`: `Array<0ArrayPattern | 0Identifier | 0ObjectPattern | 0RestElement>` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSTypeElement`](#tstypeelement)

---

#### tsConditionalType[#](#tsconditionaltype)

<Code language="javascript">t.tsConditionalType(checkType, extendsType, trueType, falseType);</Code>
*TSConditionalType*
<Code file="/src/codesample/tsConditionalType.js.txt" type="TSConditionalType"/>

See also `t.isTSConditionalType(node, opts)` and `t.assertTSConditionalType(node, opts)`.

AST Node `TSConditionalType` shape:
- `checkType`: `0TSType` (required)
- `extendsType`: `0TSType` (required)
- `trueType`: `0TSType` (required)
- `falseType`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsConstructSignatureDeclaration[#](#tsconstructsignaturedeclaration)

<Code language="javascript">t.tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation);</Code>
*TSConstructSignatureDeclaration*
<Code file="/src/codesample/tsConstructSignatureDeclaration.js.txt" type="TSConstructSignatureDeclaration"/>

See also `t.isTSConstructSignatureDeclaration(node, opts)` and `t.assertTSConstructSignatureDeclaration(node, opts)`.

AST Node `TSConstructSignatureDeclaration` shape:
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `parameters`: `Array<0ArrayPattern | 0Identifier | 0ObjectPattern | 0RestElement>` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSTypeElement`](#tstypeelement)

---

#### tsConstructorType[#](#tsconstructortype)

<Code language="javascript">t.tsConstructorType(typeParameters, parameters, typeAnnotation);</Code>
*TSConstructorType*
<Code file="/src/codesample/tsConstructorType.js.txt" type="TSConstructorType"/>

See also `t.isTSConstructorType(node, opts)` and `t.assertTSConstructorType(node, opts)`.

AST Node `TSConstructorType` shape:
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `parameters`: `Array<0ArrayPattern | 0Identifier | 0ObjectPattern | 0RestElement>` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsDeclareFunction[#](#tsdeclarefunction)

<Code language="javascript">t.tsDeclareFunction(id, typeParameters, params, returnType);</Code>
*TSDeclareFunction*
<Code file="/src/codesample/tsDeclareFunction.js.txt" type="TSDeclareFunction"/>

See also `t.isTSDeclareFunction(node, opts)` and `t.assertTSDeclareFunction(node, opts)`.

AST Node `TSDeclareFunction` shape:
- `id`: `0Identifier` (default: `null`)
- `typeParameters`: `0TSTypeParameterDeclaration | 0Noop` (default: `null`)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement>` (required)
- `returnType`: `0TSTypeAnnotation | 0Noop` (default: `null`)
- `async`: `boolean` (default: `false`, excluded from builder function)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `generator`: `boolean` (default: `false`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### tsDeclareMethod[#](#tsdeclaremethod)

<Code language="javascript">t.tsDeclareMethod(decorators, key, typeParameters, params, returnType);</Code>
*TSDeclareMethod*
<Code file="/src/codesample/tsDeclareMethod.js.txt" type="TSDeclareMethod"/>

See also `t.isTSDeclareMethod(node, opts)` and `t.assertTSDeclareMethod(node, opts)`.

AST Node `TSDeclareMethod` shape:
- `decorators`: `Array<0Decorator>` (default: `null`)
- `key`: `0Identifier | 0StringLiteral | 0NumericLiteral | 0BigIntLiteral | 0Expression` (required)
- `typeParameters`: `0TSTypeParameterDeclaration | 0Noop` (default: `null`)
- `params`: `Array<0Identifier | 0Pattern | 0RestElement | 0TSParameterProperty>` (required)
- `returnType`: `0TSTypeAnnotation | 0Noop` (default: `null`)
- `abstract`: `boolean` (default: `null`, excluded from builder function)
- `access`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `accessibility`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `async`: `boolean` (default: `false`, excluded from builder function)
- `computed`: `boolean` (default: `false`, excluded from builder function)
- `generator`: `boolean` (default: `false`, excluded from builder function)
- `kind`: `"get" | "set" | "method" | "constructor"` (default: `'method'`, excluded from builder function)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `override`: `boolean` (default: `false`, excluded from builder function)
- `static`: `boolean` (default: `false`, excluded from builder function)

Aliases: [`TypeScript`](#typescript)

---

#### tsEnumDeclaration[#](#tsenumdeclaration)

<Code language="javascript">t.tsEnumDeclaration(id, members);</Code>
*TSEnumDeclaration*
<Code file="/src/codesample/tsEnumDeclaration.js.txt" type="TSEnumDeclaration"/>

See also `t.isTSEnumDeclaration(node, opts)` and `t.assertTSEnumDeclaration(node, opts)`.

AST Node `TSEnumDeclaration` shape:
- `id`: `0Identifier` (required)
- `members`: `Array<0TSEnumMember>` (required)
- `const`: `boolean` (default: `null`, excluded from builder function)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `initializer`: `0Expression` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### tsEnumMember[#](#tsenummember)

<Code language="javascript">t.tsEnumMember(id, initializer);</Code>
*TSEnumMember*
<Code file="/src/codesample/tsEnumMember.js.txt" type="TSEnumMember"/>

See also `t.isTSEnumMember(node, opts)` and `t.assertTSEnumMember(node, opts)`.

AST Node `TSEnumMember` shape:
- `id`: `0Identifier | 0StringLiteral` (required)
- `initializer`: `0Expression` (default: `null`)

Aliases: [`TypeScript`](#typescript)

---

#### tsExportAssignment[#](#tsexportassignment)

<Code language="javascript">t.tsExportAssignment(expression);</Code>
*TSExportAssignment*
<Code file="/src/codesample/tsExportAssignment.js.txt" type="TSExportAssignment"/>

See also `t.isTSExportAssignment(node, opts)` and `t.assertTSExportAssignment(node, opts)`.

AST Node `TSExportAssignment` shape:
- `expression`: `0Expression` (required)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement)

---

#### tsExpressionWithTypeArguments[#](#tsexpressionwithtypearguments)

<Code language="javascript">t.tsExpressionWithTypeArguments(expression, typeParameters);</Code>
*TSExpressionWithTypeArguments*
<Code file="/src/codesample/tsExpressionWithTypeArguments.js.txt" type="TSExpressionWithTypeArguments"/>

See also `t.isTSExpressionWithTypeArguments(node, opts)` and `t.assertTSExpressionWithTypeArguments(node, opts)`.

AST Node `TSExpressionWithTypeArguments` shape:
- `expression`: `0TSEntityName` (required)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsExternalModuleReference[#](#tsexternalmodulereference)

<Code language="javascript">t.tsExternalModuleReference(expression);</Code>
*TSExternalModuleReference*
<Code file="/src/codesample/tsExternalModuleReference.js.txt" type="TSExternalModuleReference"/>

See also `t.isTSExternalModuleReference(node, opts)` and `t.assertTSExternalModuleReference(node, opts)`.

AST Node `TSExternalModuleReference` shape:
- `expression`: `0StringLiteral` (required)

Aliases: [`TypeScript`](#typescript)

---

#### tsFunctionType[#](#tsfunctiontype)

<Code language="javascript">t.tsFunctionType(typeParameters, parameters, typeAnnotation);</Code>
*TSFunctionType*
<Code file="/src/codesample/tsFunctionType.js.txt" type="TSFunctionType"/>

See also `t.isTSFunctionType(node, opts)` and `t.assertTSFunctionType(node, opts)`.

AST Node `TSFunctionType` shape:
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `parameters`: `Array<0ArrayPattern | 0Identifier | 0ObjectPattern | 0RestElement>` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsImportEqualsDeclaration[#](#tsimportequalsdeclaration)

<Code language="javascript">t.tsImportEqualsDeclaration(id, moduleReference);</Code>
*TSImportEqualsDeclaration*
<Code file="/src/codesample/tsImportEqualsDeclaration.js.txt" type="TSImportEqualsDeclaration"/>

See also `t.isTSImportEqualsDeclaration(node, opts)` and `t.assertTSImportEqualsDeclaration(node, opts)`.

AST Node `TSImportEqualsDeclaration` shape:
- `id`: `0Identifier` (required)
- `moduleReference`: `0TSEntityName | 0TSExternalModuleReference` (required)
- `importKind`: `"type" | "value"` (default: `null`, excluded from builder function)
- `isExport`: `boolean` (required)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement)

---

#### tsImportType[#](#tsimporttype)

<Code language="javascript">t.tsImportType(argument, qualifier, typeParameters);</Code>
*TSImportType*
<Code file="/src/codesample/tsImportType.js.txt" type="TSImportType"/>

See also `t.isTSImportType(node, opts)` and `t.assertTSImportType(node, opts)`.

AST Node `TSImportType` shape:
- `argument`: `0StringLiteral` (required)
- `qualifier`: `0TSEntityName` (default: `null`)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsIndexSignature[#](#tsindexsignature)

<Code language="javascript">t.tsIndexSignature(parameters, typeAnnotation);</Code>
*TSIndexSignature*
<Code file="/src/codesample/tsIndexSignature.js.txt" type="TSIndexSignature"/>

See also `t.isTSIndexSignature(node, opts)` and `t.assertTSIndexSignature(node, opts)`.

AST Node `TSIndexSignature` shape:
- `parameters`: `Array<0Identifier>` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)
- `readonly`: `boolean` (default: `null`, excluded from builder function)
- `static`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`TSTypeElement`](#tstypeelement)

---

#### tsIndexedAccessType[#](#tsindexedaccesstype)

<Code language="javascript">t.tsIndexedAccessType(objectType, indexType);</Code>
*TSIndexedAccessType*
<Code file="/src/codesample/tsIndexedAccessType.js.txt" type="TSIndexedAccessType"/>

See also `t.isTSIndexedAccessType(node, opts)` and `t.assertTSIndexedAccessType(node, opts)`.

AST Node `TSIndexedAccessType` shape:
- `objectType`: `0TSType` (required)
- `indexType`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsInferType[#](#tsinfertype)

<Code language="javascript">t.tsInferType(typeParameter);</Code>
*TSInferType*
<Code file="/src/codesample/tsInferType.js.txt" type="TSInferType"/>

See also `t.isTSInferType(node, opts)` and `t.assertTSInferType(node, opts)`.

AST Node `TSInferType` shape:
- `typeParameter`: `0TSTypeParameter` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsInstantiationExpression[#](#tsinstantiationexpression)

<Code language="javascript">t.tsInstantiationExpression(expression, typeParameters);</Code>
*TSInstantiationExpression*
<Code file="/src/codesample/tsInstantiationExpression.js.txt" type="TSInstantiationExpression"/>

See also `t.isTSInstantiationExpression(node, opts)` and `t.assertTSInstantiationExpression(node, opts)`.

AST Node `TSInstantiationExpression` shape:
- `expression`: `0Expression` (required)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`Expression`](#expression)

---

#### tsInterfaceBody[#](#tsinterfacebody)

<Code language="javascript">t.tsInterfaceBody(body);</Code>
*TSInterfaceBody*
<Code file="/src/codesample/tsInterfaceBody.js.txt" type="TSInterfaceBody"/>

See also `t.isTSInterfaceBody(node, opts)` and `t.assertTSInterfaceBody(node, opts)`.

AST Node `TSInterfaceBody` shape:
- `body`: `Array<0TSTypeElement>` (required)

Aliases: [`TypeScript`](#typescript)

---

#### tsInterfaceDeclaration[#](#tsinterfacedeclaration)

<Code language="javascript">t.tsInterfaceDeclaration(id, typeParameters, extends, body);</Code>
*TSInterfaceDeclaration*
<Code file="/src/codesample/tsInterfaceDeclaration.js.txt" type="TSInterfaceDeclaration"/>

See also `t.isTSInterfaceDeclaration(node, opts)` and `t.assertTSInterfaceDeclaration(node, opts)`.

AST Node `TSInterfaceDeclaration` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `extends`: `Array<0TSExpressionWithTypeArguments>` (default: `null`)
- `body`: `0TSInterfaceBody` (required)
- `declare`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### tsIntersectionType[#](#tsintersectiontype)

<Code language="javascript">t.tsIntersectionType(types);</Code>
*TSIntersectionType*
<Code file="/src/codesample/tsIntersectionType.js.txt" type="TSIntersectionType"/>

See also `t.isTSIntersectionType(node, opts)` and `t.assertTSIntersectionType(node, opts)`.

AST Node `TSIntersectionType` shape:
- `types`: `Array<0TSType>` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsIntrinsicKeyword[#](#tsintrinsickeyword)

<Code language="javascript">t.tsIntrinsicKeyword();</Code>
*TSIntrinsicKeyword*
<Code file="/src/codesample/tsIntrinsicKeyword.js.txt" type="TSIntrinsicKeyword"/>

See also `t.isTSIntrinsicKeyword(node, opts)` and `t.assertTSIntrinsicKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsLiteralType[#](#tsliteraltype)

<Code language="javascript">t.tsLiteralType(literal);</Code>
*TSLiteralType*
<Code file="/src/codesample/tsLiteralType.js.txt" type="TSLiteralType"/>

See also `t.isTSLiteralType(node, opts)` and `t.assertTSLiteralType(node, opts)`.

AST Node `TSLiteralType` shape:
- `literal`: `0NumericLiteral | 0StringLiteral | 0BooleanLiteral | 0BigIntLiteral | 0TemplateLiteral | 0UnaryExpression` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsMappedType[#](#tsmappedtype)

<Code language="javascript">t.tsMappedType(typeParameter, typeAnnotation, nameType);</Code>
*TSMappedType*
<Code file="/src/codesample/tsMappedType.js.txt" type="TSMappedType"/>

See also `t.isTSMappedType(node, opts)` and `t.assertTSMappedType(node, opts)`.

AST Node `TSMappedType` shape:
- `typeParameter`: `0TSTypeParameter` (required)
- `typeAnnotation`: `0TSType` (default: `null`)
- `nameType`: `0TSType` (default: `null`)
- `optional`: `true | false | "+" | "-"` (default: `null`, excluded from builder function)
- `readonly`: `true | false | "+" | "-"` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsMethodSignature[#](#tsmethodsignature)

<Code language="javascript">t.tsMethodSignature(key, typeParameters, parameters, typeAnnotation);</Code>
*TSMethodSignature*
<Code file="/src/codesample/tsMethodSignature.js.txt" type="TSMethodSignature"/>

See also `t.isTSMethodSignature(node, opts)` and `t.assertTSMethodSignature(node, opts)`.

AST Node `TSMethodSignature` shape:
- `key`: `0Expression` (required)
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `parameters`: `Array<0ArrayPattern | 0Identifier | 0ObjectPattern | 0RestElement>` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)
- `computed`: `boolean` (default: `false`, excluded from builder function)
- `kind`: `"method" | "get" | "set"` (required)
- `optional`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`TSTypeElement`](#tstypeelement)

---

#### tsModuleBlock[#](#tsmoduleblock)

<Code language="javascript">t.tsModuleBlock(body);</Code>
*TSModuleBlock*
<Code file="/src/codesample/tsModuleBlock.js.txt" type="TSModuleBlock"/>

See also `t.isTSModuleBlock(node, opts)` and `t.assertTSModuleBlock(node, opts)`.

AST Node `TSModuleBlock` shape:
- `body`: `Array<0Statement>` (required)

Aliases: [`TypeScript`](#typescript), [`Scopable`](#scopable), [`Block`](#block), [`BlockParent`](#blockparent), [`FunctionParent`](#functionparent)

---

#### tsModuleDeclaration[#](#tsmoduledeclaration)

<Code language="javascript">t.tsModuleDeclaration(id, body);</Code>
*TSModuleDeclaration*
<Code file="/src/codesample/tsModuleDeclaration.js.txt" type="TSModuleDeclaration"/>

See also `t.isTSModuleDeclaration(node, opts)` and `t.assertTSModuleDeclaration(node, opts)`.

AST Node `TSModuleDeclaration` shape:
- `id`: `0Identifier | 0StringLiteral` (required)
- `body`: `0TSModuleBlock | 0TSModuleDeclaration` (required)
- `declare`: `boolean` (default: `null`, excluded from builder function)
- `global`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### tsNamedTupleMember[#](#tsnamedtuplemember)

<Code language="javascript">t.tsNamedTupleMember(label, elementType, optional);</Code>
*TSNamedTupleMember*
<Code file="/src/codesample/tsNamedTupleMember.js.txt" type="TSNamedTupleMember"/>

See also `t.isTSNamedTupleMember(node, opts)` and `t.assertTSNamedTupleMember(node, opts)`.

AST Node `TSNamedTupleMember` shape:
- `label`: `0Identifier` (required)
- `elementType`: `0TSType` (required)
- `optional`: `boolean` (default: `false`)

Aliases: [`TypeScript`](#typescript)

---

#### tsNamespaceExportDeclaration[#](#tsnamespaceexportdeclaration)

<Code language="javascript">t.tsNamespaceExportDeclaration(id);</Code>
*TSNamespaceExportDeclaration*
<Code file="/src/codesample/tsNamespaceExportDeclaration.js.txt" type="TSNamespaceExportDeclaration"/>

See also `t.isTSNamespaceExportDeclaration(node, opts)` and `t.assertTSNamespaceExportDeclaration(node, opts)`.

AST Node `TSNamespaceExportDeclaration` shape:
- `id`: `0Identifier` (required)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement)

---

#### tsNeverKeyword[#](#tsneverkeyword)

<Code language="javascript">t.tsNeverKeyword();</Code>
*TSNeverKeyword*
<Code file="/src/codesample/tsNeverKeyword.js.txt" type="TSNeverKeyword"/>

See also `t.isTSNeverKeyword(node, opts)` and `t.assertTSNeverKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsNonNullExpression[#](#tsnonnullexpression)

<Code language="javascript">t.tsNonNullExpression(expression);</Code>
*TSNonNullExpression*
<Code file="/src/codesample/tsNonNullExpression.js.txt" type="TSNonNullExpression"/>

See also `t.isTSNonNullExpression(node, opts)` and `t.assertTSNonNullExpression(node, opts)`.

AST Node `TSNonNullExpression` shape:
- `expression`: `0Expression` (required)

Aliases: [`TypeScript`](#typescript), [`Expression`](#expression), [`LVal`](#lval), [`PatternLike`](#patternlike)

---

#### tsNullKeyword[#](#tsnullkeyword)

<Code language="javascript">t.tsNullKeyword();</Code>
*TSNullKeyword*
<Code file="/src/codesample/tsNullKeyword.js.txt" type="TSNullKeyword"/>

See also `t.isTSNullKeyword(node, opts)` and `t.assertTSNullKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsNumberKeyword[#](#tsnumberkeyword)

<Code language="javascript">t.tsNumberKeyword();</Code>
*TSNumberKeyword*
<Code file="/src/codesample/tsNumberKeyword.js.txt" type="TSNumberKeyword"/>

See also `t.isTSNumberKeyword(node, opts)` and `t.assertTSNumberKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsObjectKeyword[#](#tsobjectkeyword)

<Code language="javascript">t.tsObjectKeyword();</Code>
*TSObjectKeyword*
<Code file="/src/codesample/tsObjectKeyword.js.txt" type="TSObjectKeyword"/>

See also `t.isTSObjectKeyword(node, opts)` and `t.assertTSObjectKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsOptionalType[#](#tsoptionaltype)

<Code language="javascript">t.tsOptionalType(typeAnnotation);</Code>
*TSOptionalType*
<Code file="/src/codesample/tsOptionalType.js.txt" type="TSOptionalType"/>

See also `t.isTSOptionalType(node, opts)` and `t.assertTSOptionalType(node, opts)`.

AST Node `TSOptionalType` shape:
- `typeAnnotation`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsParameterProperty[#](#tsparameterproperty)

<Code language="javascript">t.tsParameterProperty(parameter);</Code>
*TSParameterProperty*
<Code file="/src/codesample/tsParameterProperty.js.txt" type="TSParameterProperty"/>

See also `t.isTSParameterProperty(node, opts)` and `t.assertTSParameterProperty(node, opts)`.

AST Node `TSParameterProperty` shape:
- `parameter`: `0Identifier | 0AssignmentPattern` (required)
- `accessibility`: `"public" | "private" | "protected"` (default: `null`, excluded from builder function)
- `decorators`: `Array<0Decorator>` (default: `null`, excluded from builder function)
- `override`: `boolean` (default: `null`, excluded from builder function)
- `readonly`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`LVal`](#lval)

---

#### tsParenthesizedType[#](#tsparenthesizedtype)

<Code language="javascript">t.tsParenthesizedType(typeAnnotation);</Code>
*TSParenthesizedType*
<Code file="/src/codesample/tsParenthesizedType.js.txt" type="TSParenthesizedType"/>

See also `t.isTSParenthesizedType(node, opts)` and `t.assertTSParenthesizedType(node, opts)`.

AST Node `TSParenthesizedType` shape:
- `typeAnnotation`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsPropertySignature[#](#tspropertysignature)

<Code language="javascript">t.tsPropertySignature(key, typeAnnotation, initializer);</Code>
*TSPropertySignature*
<Code file="/src/codesample/tsPropertySignature.js.txt" type="TSPropertySignature"/>

See also `t.isTSPropertySignature(node, opts)` and `t.assertTSPropertySignature(node, opts)`.

AST Node `TSPropertySignature` shape:
- `key`: `0Expression` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)
- `initializer`: `0Expression` (default: `null`)
- `computed`: `boolean` (default: `false`, excluded from builder function)
- `kind`: `"get" | "set"` (required)
- `optional`: `boolean` (default: `null`, excluded from builder function)
- `readonly`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`TSTypeElement`](#tstypeelement)

---

#### tsQualifiedName[#](#tsqualifiedname)

<Code language="javascript">t.tsQualifiedName(left, right);</Code>
*TSQualifiedName*
<Code file="/src/codesample/tsQualifiedName.js.txt" type="TSQualifiedName"/>

See also `t.isTSQualifiedName(node, opts)` and `t.assertTSQualifiedName(node, opts)`.

AST Node `TSQualifiedName` shape:
- `left`: `0TSEntityName` (required)
- `right`: `0Identifier` (required)

Aliases: [`TypeScript`](#typescript), [`TSEntityName`](#tsentityname)

---

#### tsRestType[#](#tsresttype)

<Code language="javascript">t.tsRestType(typeAnnotation);</Code>
*TSRestType*
<Code file="/src/codesample/tsRestType.js.txt" type="TSRestType"/>

See also `t.isTSRestType(node, opts)` and `t.assertTSRestType(node, opts)`.

AST Node `TSRestType` shape:
- `typeAnnotation`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsSatisfiesExpression[#](#tssatisfiesexpression)

<Code language="javascript">t.tsSatisfiesExpression(expression, typeAnnotation);</Code>
*TSSatisfiesExpression*
<Code file="/src/codesample/tsSatisfiesExpression.js.txt" type="TSSatisfiesExpression"/>

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.20.0` | Introduced |
</details>

See also `t.isTSSatisfiesExpression(node, opts)` and `t.assertTSSatisfiesExpression(node, opts)`.

AST Node `TSSatisfiesExpression` shape:
- `expression`: `0Expression` (required)
- `typeAnnotation`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript), [`Expression`](#expression), [`LVal`](#lval), [`PatternLike`](#patternlike)

---

#### tsStringKeyword[#](#tsstringkeyword)

<Code language="javascript">t.tsStringKeyword();</Code>
*TSStringKeyword*
<Code file="/src/codesample/tsStringKeyword.js.txt" type="TSStringKeyword"/>

See also `t.isTSStringKeyword(node, opts)` and `t.assertTSStringKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsSymbolKeyword[#](#tssymbolkeyword)

<Code language="javascript">t.tsSymbolKeyword();</Code>
*TSSymbolKeyword*
<Code file="/src/codesample/tsSymbolKeyword.js.txt" type="TSSymbolKeyword"/>

See also `t.isTSSymbolKeyword(node, opts)` and `t.assertTSSymbolKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsThisType[#](#tsthistype)

<Code language="javascript">t.tsThisType();</Code>
*TSThisType*
<Code file="/src/codesample/tsThisType.js.txt" type="TSThisType"/>

See also `t.isTSThisType(node, opts)` and `t.assertTSThisType(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsTupleType[#](#tstupletype)

<Code language="javascript">t.tsTupleType(elementTypes);</Code>
*TSTupleType*
<Code file="/src/codesample/tsTupleType.js.txt" type="TSTupleType"/>

See also `t.isTSTupleType(node, opts)` and `t.assertTSTupleType(node, opts)`.

AST Node `TSTupleType` shape:
- `elementTypes`: `Array<0TSType | 0TSNamedTupleMember>` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsTypeAliasDeclaration[#](#tstypealiasdeclaration)

<Code language="javascript">t.tsTypeAliasDeclaration(id, typeParameters, typeAnnotation);</Code>
*TSTypeAliasDeclaration*
<Code file="/src/codesample/tsTypeAliasDeclaration.js.txt" type="TSTypeAliasDeclaration"/>

See also `t.isTSTypeAliasDeclaration(node, opts)` and `t.assertTSTypeAliasDeclaration(node, opts)`.

AST Node `TSTypeAliasDeclaration` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TSTypeParameterDeclaration` (default: `null`)
- `typeAnnotation`: `0TSType` (required)
- `declare`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### tsTypeAnnotation[#](#tstypeannotation)

<Code language="javascript">t.tsTypeAnnotation(typeAnnotation);</Code>
*TSTypeAnnotation*
<Code file="/src/codesample/tsTypeAnnotation.js.txt" type="TSTypeAnnotation"/>

See also `t.isTSTypeAnnotation(node, opts)` and `t.assertTSTypeAnnotation(node, opts)`.

AST Node `TSTypeAnnotation` shape:
- `typeAnnotation`: `0TSType` (required)

Aliases: [`TypeScript`](#typescript)

---

#### tsTypeAssertion[#](#tstypeassertion)

<Code language="javascript">t.tsTypeAssertion(typeAnnotation, expression);</Code>
*TSTypeAssertion*
<Code file="/src/codesample/tsTypeAssertion.js.txt" type="TSTypeAssertion"/>

See also `t.isTSTypeAssertion(node, opts)` and `t.assertTSTypeAssertion(node, opts)`.

AST Node `TSTypeAssertion` shape:
- `typeAnnotation`: `0TSType` (required)
- `expression`: `0Expression` (required)

Aliases: [`TypeScript`](#typescript), [`Expression`](#expression), [`LVal`](#lval), [`PatternLike`](#patternlike)

---

#### tsTypeLiteral[#](#tstypeliteral)

<Code language="javascript">t.tsTypeLiteral(members);</Code>
*TSTypeLiteral*
<Code file="/src/codesample/tsTypeLiteral.js.txt" type="TSTypeLiteral"/>

See also `t.isTSTypeLiteral(node, opts)` and `t.assertTSTypeLiteral(node, opts)`.

AST Node `TSTypeLiteral` shape:
- `members`: `Array<0TSTypeElement>` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsTypeOperator[#](#tstypeoperator)

<Code language="javascript">t.tsTypeOperator(typeAnnotation);</Code>
*TSTypeOperator*
<Code file="/src/codesample/tsTypeOperator.js.txt" type="TSTypeOperator"/>

See also `t.isTSTypeOperator(node, opts)` and `t.assertTSTypeOperator(node, opts)`.

AST Node `TSTypeOperator` shape:
- `typeAnnotation`: `0TSType` (required)
- `operator`: `string` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsTypeParameter[#](#tstypeparameter)

<Code language="javascript">t.tsTypeParameter(constraint, default, name);</Code>
*TSTypeParameter*
<Code file="/src/codesample/tsTypeParameter.js.txt" type="TSTypeParameter"/>

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.21.0` | Supports `const` |
</details>

See also `t.isTSTypeParameter(node, opts)` and `t.assertTSTypeParameter(node, opts)`.

AST Node `TSTypeParameter` shape:
- `constraint`: `0TSType` (default: `null`)
- `default`: `0TSType` (default: `null`)
- `name`: `string` (required)
- `const`: `boolean` (default: `null`, excluded from builder function)
- `in`: `boolean` (default: `null`, excluded from builder function)
- `out`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`TypeScript`](#typescript)

---

#### tsTypeParameterDeclaration[#](#tstypeparameterdeclaration)

<Code language="javascript">t.tsTypeParameterDeclaration(params);</Code>
*TSTypeParameterDeclaration*
<Code file="/src/codesample/tsTypeParameterDeclaration.js.txt" type="TSTypeParameterDeclaration"/>

See also `t.isTSTypeParameterDeclaration(node, opts)` and `t.assertTSTypeParameterDeclaration(node, opts)`.

AST Node `TSTypeParameterDeclaration` shape:
- `params`: `Array<0TSTypeParameter>` (required)

Aliases: [`TypeScript`](#typescript)

---

#### tsTypeParameterInstantiation[#](#tstypeparameterinstantiation)

<Code language="javascript">t.tsTypeParameterInstantiation(params);</Code>
*TSTypeParameterInstantiation*
<Code file="/src/codesample/tsTypeParameterInstantiation.js.txt" type="TSTypeParameterInstantiation"/>

See also `t.isTSTypeParameterInstantiation(node, opts)` and `t.assertTSTypeParameterInstantiation(node, opts)`.

AST Node `TSTypeParameterInstantiation` shape:
- `params`: `Array<0TSType>` (required)

Aliases: [`TypeScript`](#typescript)

---

#### tsTypePredicate[#](#tstypepredicate)

<Code language="javascript">t.tsTypePredicate(parameterName, typeAnnotation, asserts);</Code>
*TSTypePredicate*
<Code file="/src/codesample/tsTypePredicate.js.txt" type="TSTypePredicate"/>

See also `t.isTSTypePredicate(node, opts)` and `t.assertTSTypePredicate(node, opts)`.

AST Node `TSTypePredicate` shape:
- `parameterName`: `0Identifier | 0TSThisType` (required)
- `typeAnnotation`: `0TSTypeAnnotation` (default: `null`)
- `asserts`: `boolean` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsTypeQuery[#](#tstypequery)

<Code language="javascript">t.tsTypeQuery(exprName, typeParameters);</Code>
*TSTypeQuery*
<Code file="/src/codesample/tsTypeQuery.js.txt" type="TSTypeQuery"/>

See also `t.isTSTypeQuery(node, opts)` and `t.assertTSTypeQuery(node, opts)`.

AST Node `TSTypeQuery` shape:
- `exprName`: `0TSEntityName | 0TSImportType` (required)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsTypeReference[#](#tstypereference)

<Code language="javascript">t.tsTypeReference(typeName, typeParameters);</Code>
*TSTypeReference*
<Code file="/src/codesample/tsTypeReference.js.txt" type="TSTypeReference"/>

See also `t.isTSTypeReference(node, opts)` and `t.assertTSTypeReference(node, opts)`.

AST Node `TSTypeReference` shape:
- `typeName`: `0TSEntityName` (required)
- `typeParameters`: `0TSTypeParameterInstantiation` (default: `null`)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsUndefinedKeyword[#](#tsundefinedkeyword)

<Code language="javascript">t.tsUndefinedKeyword();</Code>
*TSUndefinedKeyword*
<Code file="/src/codesample/tsUndefinedKeyword.js.txt" type="TSUndefinedKeyword"/>

See also `t.isTSUndefinedKeyword(node, opts)` and `t.assertTSUndefinedKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsUnionType[#](#tsuniontype)

<Code language="javascript">t.tsUnionType(types);</Code>
*TSUnionType*
<Code file="/src/codesample/tsUnionType.js.txt" type="TSUnionType"/>

See also `t.isTSUnionType(node, opts)` and `t.assertTSUnionType(node, opts)`.

AST Node `TSUnionType` shape:
- `types`: `Array<0TSType>` (required)

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype)

---

#### tsUnknownKeyword[#](#tsunknownkeyword)

<Code language="javascript">t.tsUnknownKeyword();</Code>
*TSUnknownKeyword*
<Code file="/src/codesample/tsUnknownKeyword.js.txt" type="TSUnknownKeyword"/>

See also `t.isTSUnknownKeyword(node, opts)` and `t.assertTSUnknownKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### tsVoidKeyword[#](#tsvoidkeyword)

<Code language="javascript">t.tsVoidKeyword();</Code>
*TSVoidKeyword*
<Code file="/src/codesample/tsVoidKeyword.js.txt" type="TSVoidKeyword"/>

See also `t.isTSVoidKeyword(node, opts)` and `t.assertTSVoidKeyword(node, opts)`.

Aliases: [`TypeScript`](#typescript), [`TSType`](#tstype), [`TSBaseType`](#tsbasetype)

---

#### taggedTemplateExpression[#](#taggedtemplateexpression)

<Code language="javascript">t.taggedTemplateExpression(tag, quasi);</Code>
*TaggedTemplateExpression*
<Code file="/src/codesample/taggedTemplateExpression.js.txt" type="TaggedTemplateExpression"/>

See also `t.isTaggedTemplateExpression(node, opts)` and `t.assertTaggedTemplateExpression(node, opts)`.

AST Node `TaggedTemplateExpression` shape:
- `tag`: `0Expression` (required)
- `quasi`: `0TemplateLiteral` (required)
- `typeParameters`: `0TypeParameterInstantiation | 0TSTypeParameterInstantiation` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### templateElement[#](#templateelement)

<Code language="javascript">t.templateElement(value, tail);</Code>
*TemplateElement*
<Code file="/src/codesample/templateElement.js.txt" type="TemplateElement"/>

See also `t.isTemplateElement(node, opts)` and `t.assertTemplateElement(node, opts)`.

AST Node `TemplateElement` shape:
- `value`: `{ raw: string, cooked?: string }` (required)
- `tail`: `boolean` (default: `false`)

Aliases: [`Standardized`](#standardized)

---

#### templateLiteral[#](#templateliteral)

<Code language="javascript">t.templateLiteral(quasis, expressions);</Code>
*TemplateLiteral*
<Code file="/src/codesample/templateLiteral.js.txt" type="TemplateLiteral"/>

See also `t.isTemplateLiteral(node, opts)` and `t.assertTemplateLiteral(node, opts)`.

AST Node `TemplateLiteral` shape:
- `quasis`: `Array<0TemplateElement>` (required)
- `expressions`: `Array<0Expression | 0TSType>` (required)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Literal`](#literal)

---

#### thisExpression[#](#thisexpression)

<Code language="javascript">t.thisExpression();</Code>
*ThisExpression*
<Code file="/src/codesample/thisExpression.js.txt" type="ThisExpression"/>

See also `t.isThisExpression(node, opts)` and `t.assertThisExpression(node, opts)`.

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### thisTypeAnnotation[#](#thistypeannotation)

<Code language="javascript">t.thisTypeAnnotation();</Code>
*ThisTypeAnnotation*
<Code file="/src/codesample/thisTypeAnnotation.js.txt" type="ThisTypeAnnotation"/>

See also `t.isThisTypeAnnotation(node, opts)` and `t.assertThisTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### throwStatement[#](#throwstatement)

<Code language="javascript">t.throwStatement(argument);</Code>
*ThrowStatement*
<Code file="/src/codesample/throwStatement.js.txt" type="ThrowStatement"/>

See also `t.isThrowStatement(node, opts)` and `t.assertThrowStatement(node, opts)`.

AST Node `ThrowStatement` shape:
- `argument`: `0Expression` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Terminatorless`](#terminatorless), [`CompletionStatement`](#completionstatement)

---

#### topicReference[#](#topicreference)

<Code language="javascript">t.topicReference();</Code>
*TopicReference*
<Code file="/src/codesample/topicReference.js.txt" type="TopicReference"/>

See also `t.isTopicReference(node, opts)` and `t.assertTopicReference(node, opts)`.

Aliases: [`Expression`](#expression)

---

#### tryStatement[#](#trystatement)

<Code language="javascript">t.tryStatement(block, handler, finalizer);</Code>
*TryStatement*
<Code file="/src/codesample/tryStatement.js.txt" type="TryStatement"/>

See also `t.isTryStatement(node, opts)` and `t.assertTryStatement(node, opts)`.

AST Node `TryStatement` shape:
- `block`: `0BlockStatement` (required)
- `handler`: `0CatchClause` (default: `null`)
- `finalizer`: `0BlockStatement` (default: `null`)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement)

---

#### tupleExpression[#](#tupleexpression)

<Code language="javascript">t.tupleExpression(elements);</Code>
*TupleExpression*
<Code file="/src/codesample/tupleExpression.js.txt" type="TupleExpression"/>

See also `t.isTupleExpression(node, opts)` and `t.assertTupleExpression(node, opts)`.

AST Node `TupleExpression` shape:
- `elements`: `Array<0Expression | 0SpreadElement>` (default: `[]`)

Aliases: [`Expression`](#expression)

---

#### tupleTypeAnnotation[#](#tupletypeannotation)

<Code language="javascript">t.tupleTypeAnnotation(types);</Code>
*TupleTypeAnnotation*
<Code file="/src/codesample/tupleTypeAnnotation.js.txt" type="TupleTypeAnnotation"/>

See also `t.isTupleTypeAnnotation(node, opts)` and `t.assertTupleTypeAnnotation(node, opts)`.

AST Node `TupleTypeAnnotation` shape:
- `types`: `Array<0FlowType>` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### typeAlias[#](#typealias)

<Code language="javascript">t.typeAlias(id, typeParameters, right);</Code>
*TypeAlias*
<Code file="/src/codesample/typeAlias.js.txt" type="TypeAlias"/>

See also `t.isTypeAlias(node, opts)` and `t.assertTypeAlias(node, opts)`.

AST Node `TypeAlias` shape:
- `id`: `0Identifier` (required)
- `typeParameters`: `0TypeParameterDeclaration` (default: `null`)
- `right`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowDeclaration`](#flowdeclaration), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### typeAnnotation[#](#typeannotation)

<Code language="javascript">t.typeAnnotation(typeAnnotation);</Code>
*TypeAnnotation*
<Code file="/src/codesample/typeAnnotation.js.txt" type="TypeAnnotation"/>

See also `t.isTypeAnnotation(node, opts)` and `t.assertTypeAnnotation(node, opts)`.

AST Node `TypeAnnotation` shape:
- `typeAnnotation`: `0FlowType` (required)

Aliases: [`Flow`](#flow)

---

#### typeCastExpression[#](#typecastexpression)

<Code language="javascript">t.typeCastExpression(expression, typeAnnotation);</Code>
*TypeCastExpression*
<Code file="/src/codesample/typeCastExpression.js.txt" type="TypeCastExpression"/>

See also `t.isTypeCastExpression(node, opts)` and `t.assertTypeCastExpression(node, opts)`.

AST Node `TypeCastExpression` shape:
- `expression`: `0Expression` (required)
- `typeAnnotation`: `0TypeAnnotation` (required)

Aliases: [`Flow`](#flow), [`ExpressionWrapper`](#expressionwrapper), [`Expression`](#expression)

---

#### typeParameter[#](#typeparameter)

<Code language="javascript">t.typeParameter(bound, default, variance);</Code>
*TypeParameter*
<Code file="/src/codesample/typeParameter.js.txt" type="TypeParameter"/>

See also `t.isTypeParameter(node, opts)` and `t.assertTypeParameter(node, opts)`.

AST Node `TypeParameter` shape:
- `bound`: `0TypeAnnotation` (default: `null`)
- `default`: `0FlowType` (default: `null`)
- `variance`: `0Variance` (default: `null`)
- `name`: `string` (required)

Aliases: [`Flow`](#flow)

---

#### typeParameterDeclaration[#](#typeparameterdeclaration)

<Code language="javascript">t.typeParameterDeclaration(params);</Code>
*TypeParameterDeclaration*
<Code file="/src/codesample/typeParameterDeclaration.js.txt" type="TypeParameterDeclaration"/>

See also `t.isTypeParameterDeclaration(node, opts)` and `t.assertTypeParameterDeclaration(node, opts)`.

AST Node `TypeParameterDeclaration` shape:
- `params`: `Array<0TypeParameter>` (required)

Aliases: [`Flow`](#flow)

---

#### typeParameterInstantiation[#](#typeparameterinstantiation)

<Code language="javascript">t.typeParameterInstantiation(params);</Code>
*TypeParameterInstantiation*
<Code file="/src/codesample/typeParameterInstantiation.js.txt" type="TypeParameterInstantiation"/>

See also `t.isTypeParameterInstantiation(node, opts)` and `t.assertTypeParameterInstantiation(node, opts)`.

AST Node `TypeParameterInstantiation` shape:
- `params`: `Array<0FlowType>` (required)

Aliases: [`Flow`](#flow)

---

#### typeofTypeAnnotation[#](#typeoftypeannotation)

<Code language="javascript">t.typeofTypeAnnotation(argument);</Code>
*TypeofTypeAnnotation*
<Code file="/src/codesample/typeofTypeAnnotation.js.txt" type="TypeofTypeAnnotation"/>

See also `t.isTypeofTypeAnnotation(node, opts)` and `t.assertTypeofTypeAnnotation(node, opts)`.

AST Node `TypeofTypeAnnotation` shape:
- `argument`: `0FlowType` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### unaryExpression[#](#unaryexpression)

<Code language="javascript">t.unaryExpression(operator, argument, prefix);</Code>
*UnaryExpression*
<Code file="/src/codesample/unaryExpression.js.txt" type="UnaryExpression"/>

See also `t.isUnaryExpression(node, opts)` and `t.assertUnaryExpression(node, opts)`.

AST Node `UnaryExpression` shape:
- `operator`: `"void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof"` (required)
- `argument`: `0Expression` (required)
- `prefix`: `boolean` (default: `true`)

Aliases: [`Standardized`](#standardized), [`UnaryLike`](#unarylike), [`Expression`](#expression)

---

#### unionTypeAnnotation[#](#uniontypeannotation)

<Code language="javascript">t.unionTypeAnnotation(types);</Code>
*UnionTypeAnnotation*
<Code file="/src/codesample/unionTypeAnnotation.js.txt" type="UnionTypeAnnotation"/>

See also `t.isUnionTypeAnnotation(node, opts)` and `t.assertUnionTypeAnnotation(node, opts)`.

AST Node `UnionTypeAnnotation` shape:
- `types`: `Array<0FlowType>` (required)

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype)

---

#### updateExpression[#](#updateexpression)

<Code language="javascript">t.updateExpression(operator, argument, prefix);</Code>
*UpdateExpression*
<Code file="/src/codesample/updateExpression.js.txt" type="UpdateExpression"/>

See also `t.isUpdateExpression(node, opts)` and `t.assertUpdateExpression(node, opts)`.

AST Node `UpdateExpression` shape:
- `operator`: `"++" | "--"` (required)
- `argument`: `0Expression` (required)
- `prefix`: `boolean` (default: `false`)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression)

---

#### v8IntrinsicIdentifier[#](#v8intrinsicidentifier)

<Code language="javascript">t.v8IntrinsicIdentifier(name);</Code>
*V8IntrinsicIdentifier*
<Code file="/src/codesample/v8IntrinsicIdentifier.js.txt" type="V8IntrinsicIdentifier"/>

See also `t.isV8IntrinsicIdentifier(node, opts)` and `t.assertV8IntrinsicIdentifier(node, opts)`.

AST Node `V8IntrinsicIdentifier` shape:
- `name`: `string` (required)

Aliases: [`Miscellaneous`](#miscellaneous)

---

#### variableDeclaration[#](#variabledeclaration)

<Code language="javascript">t.variableDeclaration(kind, declarations);</Code>
*VariableDeclaration*
<Code file="/src/codesample/variableDeclaration.js.txt" type="VariableDeclaration"/>

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.20.0` | `kind` can be "using". |
</details>

See also `t.isVariableDeclaration(node, opts)` and `t.assertVariableDeclaration(node, opts)`.

AST Node `VariableDeclaration` shape:
- `kind`: `"var" | "let" | "const" | "using" | "await using"` (required)
- `declarations`: `Array<0VariableDeclarator>` (required)
- `declare`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`Declaration`](#declaration)

---

#### variableDeclarator[#](#variabledeclarator)

<Code language="javascript">t.variableDeclarator(id, init);</Code>
*VariableDeclarator*
<Code file="/src/codesample/variableDeclarator.js.txt" type="VariableDeclarator"/>

See also `t.isVariableDeclarator(node, opts)` and `t.assertVariableDeclarator(node, opts)`.

AST Node `VariableDeclarator` shape:
- `id`: `0LVal` (required)
- `init`: `0Expression` (default: `null`)
- `definite`: `boolean` (default: `null`, excluded from builder function)

Aliases: [`Standardized`](#standardized)

---

#### variance[#](#variance)

<Code language="javascript">t.variance(kind);</Code>
*Variance*
<Code file="/src/codesample/variance.js.txt" type="Variance"/>

See also `t.isVariance(node, opts)` and `t.assertVariance(node, opts)`.

AST Node `Variance` shape:
- `kind`: `"minus" | "plus"` (required)

Aliases: [`Flow`](#flow)

---

#### voidTypeAnnotation[#](#voidtypeannotation)

<Code language="javascript">t.voidTypeAnnotation();</Code>
*VoidTypeAnnotation*
<Code file="/src/codesample/voidTypeAnnotation.js.txt" type="VoidTypeAnnotation"/>

See also `t.isVoidTypeAnnotation(node, opts)` and `t.assertVoidTypeAnnotation(node, opts)`.

Aliases: [`Flow`](#flow), [`FlowType`](#flowtype), [`FlowBaseAnnotation`](#flowbaseannotation)

---

#### whileStatement[#](#whilestatement)

<Code language="javascript">t.whileStatement(test, body);</Code>
*WhileStatement*
<Code file="/src/codesample/whileStatement.js.txt" type="WhileStatement"/>

See also `t.isWhileStatement(node, opts)` and `t.assertWhileStatement(node, opts)`.

AST Node `WhileStatement` shape:
- `test`: `0Expression` (required)
- `body`: `0Statement` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement), [`BlockParent`](#blockparent), [`Loop`](#loop), [`While`](#while), [`Scopable`](#scopable)

---

#### withStatement[#](#withstatement)

<Code language="javascript">t.withStatement(object, body);</Code>
*WithStatement*
<Code file="/src/codesample/withStatement.js.txt" type="WithStatement"/>

See also `t.isWithStatement(node, opts)` and `t.assertWithStatement(node, opts)`.

AST Node `WithStatement` shape:
- `object`: `0Expression` (required)
- `body`: `0Statement` (required)

Aliases: [`Standardized`](#standardized), [`Statement`](#statement)

---

#### yieldExpression[#](#yieldexpression)

<Code language="javascript">t.yieldExpression(argument, delegate);</Code>
*YieldExpression*
<Code file="/src/codesample/yieldExpression.js.txt" type="YieldExpression"/>

See also `t.isYieldExpression(node, opts)` and `t.assertYieldExpression(node, opts)`.

AST Node `YieldExpression` shape:
- `argument`: `0Expression` (default: `null`)
- `delegate`: `boolean` (default: `false`)

Aliases: [`Standardized`](#standardized), [`Expression`](#expression), [`Terminatorless`](#terminatorless)

---

### Aliases

#### Accessor

Deprecated. Will be removed in Babel 8.
```js title="JavaScript"
t.isAccessor(node);
```

Covered nodes:
- [`ClassAccessorProperty`](#classaccessorproperty)

#### Binary

A cover of BinaryExpression and LogicalExpression, which share the same AST shape.
```js title="JavaScript"
t.isBinary(node);
```

Covered nodes:
- [`BinaryExpression`](#binaryexpression)
- [`LogicalExpression`](#logicalexpression)

#### Block

Deprecated. Will be removed in Babel 8.
```js title="JavaScript"
t.isBlock(node);
```

Covered nodes:
- [`BlockStatement`](#blockstatement)
- [`Program`](#program)
- [`TSModuleBlock`](#tsmoduleblock)

#### BlockParent

A cover of AST nodes that start an execution context with new [LexicalEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `let` and `const` declarations.
```js title="JavaScript"
t.isBlockParent(node);
```

Covered nodes:
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`BlockStatement`](#blockstatement)
- [`CatchClause`](#catchclause)
- [`ClassMethod`](#classmethod)
- [`ClassPrivateMethod`](#classprivatemethod)
- [`DoWhileStatement`](#dowhilestatement)
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)
- [`ForStatement`](#forstatement)
- [`FunctionDeclaration`](#functiondeclaration)
- [`FunctionExpression`](#functionexpression)
- [`ObjectMethod`](#objectmethod)
- [`Program`](#program)
- [`StaticBlock`](#staticblock)
- [`SwitchStatement`](#switchstatement)
- [`TSModuleBlock`](#tsmoduleblock)
- [`WhileStatement`](#whilestatement)

#### Class

A cover of ClassExpression and ClassDeclaration, which share the same AST shape.
```js title="JavaScript"
t.isClass(node);
```

Covered nodes:
- [`ClassDeclaration`](#classdeclaration)
- [`ClassExpression`](#classexpression)

#### CompletionStatement

A statement that indicates the [completion records](https://tc39.es/ecma262/#sec-completion-record-specification-type). In other words, they define the control flow of the program, such as when should a loop break or an action throws critical errors.
```js title="JavaScript"
t.isCompletionStatement(node);
```

Covered nodes:
- [`BreakStatement`](#breakstatement)
- [`ContinueStatement`](#continuestatement)
- [`ReturnStatement`](#returnstatement)
- [`ThrowStatement`](#throwstatement)

#### Conditional

A cover of ConditionalExpression and IfStatement, which share the same AST shape.
```js title="JavaScript"
t.isConditional(node);
```

Covered nodes:
- [`ConditionalExpression`](#conditionalexpression)
- [`IfStatement`](#ifstatement)

#### Declaration

A cover of any [Declaration](https://tc39.es/ecma262/#prod-Declaration)s.
```js title="JavaScript"
t.isDeclaration(node);
```

Covered nodes:
- [`ClassDeclaration`](#classdeclaration)
- [`DeclareClass`](#declareclass)
- [`DeclareExportAllDeclaration`](#declareexportalldeclaration)
- [`DeclareExportDeclaration`](#declareexportdeclaration)
- [`DeclareFunction`](#declarefunction)
- [`DeclareInterface`](#declareinterface)
- [`DeclareModule`](#declaremodule)
- [`DeclareModuleExports`](#declaremoduleexports)
- [`DeclareOpaqueType`](#declareopaquetype)
- [`DeclareTypeAlias`](#declaretypealias)
- [`DeclareVariable`](#declarevariable)
- [`EnumDeclaration`](#enumdeclaration)
- [`ExportAllDeclaration`](#exportalldeclaration)
- [`ExportDefaultDeclaration`](#exportdefaultdeclaration)
- [`ExportNamedDeclaration`](#exportnameddeclaration)
- [`FunctionDeclaration`](#functiondeclaration)
- [`ImportDeclaration`](#importdeclaration)
- [`InterfaceDeclaration`](#interfacedeclaration)
- [`OpaqueType`](#opaquetype)
- [`TSDeclareFunction`](#tsdeclarefunction)
- [`TSEnumDeclaration`](#tsenumdeclaration)
- [`TSInterfaceDeclaration`](#tsinterfacedeclaration)
- [`TSModuleDeclaration`](#tsmoduledeclaration)
- [`TSTypeAliasDeclaration`](#tstypealiasdeclaration)
- [`TypeAlias`](#typealias)
- [`VariableDeclaration`](#variabledeclaration)

#### EnumBody

A cover of Flow enum bodies.
```js title="JavaScript"
t.isEnumBody(node);
```

Covered nodes:
- [`EnumBooleanBody`](#enumbooleanbody)
- [`EnumNumberBody`](#enumnumberbody)
- [`EnumStringBody`](#enumstringbody)
- [`EnumSymbolBody`](#enumsymbolbody)

#### EnumMember

A cover of Flow enum members.
```js title="JavaScript"
t.isEnumMember(node);
```

Covered nodes:
- [`EnumBooleanMember`](#enumbooleanmember)
- [`EnumDefaultedMember`](#enumdefaultedmember)
- [`EnumNumberMember`](#enumnumbermember)
- [`EnumStringMember`](#enumstringmember)

#### ExportDeclaration

A cover of any [ExportDeclaration](https://tc39.es/ecma262/#prod-ExportDeclaration)s.
```js title="JavaScript"
t.isExportDeclaration(node);
```

Covered nodes:
- [`ExportAllDeclaration`](#exportalldeclaration)
- [`ExportDefaultDeclaration`](#exportdefaultdeclaration)
- [`ExportNamedDeclaration`](#exportnameddeclaration)

#### Expression

A cover of any [Expression](https://tc39.es/ecma262/#sec-ecmascript-language-expressions)s.
```js title="JavaScript"
t.isExpression(node);
```

Covered nodes:
- [`ArrayExpression`](#arrayexpression)
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`AssignmentExpression`](#assignmentexpression)
- [`AwaitExpression`](#awaitexpression)
- [`BigIntLiteral`](#bigintliteral)
- [`BinaryExpression`](#binaryexpression)
- [`BindExpression`](#bindexpression)
- [`BooleanLiteral`](#booleanliteral)
- [`CallExpression`](#callexpression)
- [`ClassExpression`](#classexpression)
- [`ConditionalExpression`](#conditionalexpression)
- [`DecimalLiteral`](#decimalliteral)
- [`DoExpression`](#doexpression)
- [`FunctionExpression`](#functionexpression)
- [`Identifier`](#identifier)
- [`Import`](#import)
- [`ImportExpression`](#importexpression)
- [`JSXElement`](#jsxelement)
- [`JSXFragment`](#jsxfragment)
- [`LogicalExpression`](#logicalexpression)
- [`MemberExpression`](#memberexpression)
- [`MetaProperty`](#metaproperty)
- [`ModuleExpression`](#moduleexpression)
- [`NewExpression`](#newexpression)
- [`NullLiteral`](#nullliteral)
- [`NumericLiteral`](#numericliteral)
- [`ObjectExpression`](#objectexpression)
- [`OptionalCallExpression`](#optionalcallexpression)
- [`OptionalMemberExpression`](#optionalmemberexpression)
- [`ParenthesizedExpression`](#parenthesizedexpression)
- [`PipelineBareFunction`](#pipelinebarefunction)
- [`PipelinePrimaryTopicReference`](#pipelineprimarytopicreference)
- [`PipelineTopicExpression`](#pipelinetopicexpression)
- [`RecordExpression`](#recordexpression)
- [`RegExpLiteral`](#regexpliteral)
- [`SequenceExpression`](#sequenceexpression)
- [`StringLiteral`](#stringliteral)
- [`Super`](#super)
- [`TSAsExpression`](#tsasexpression)
- [`TSInstantiationExpression`](#tsinstantiationexpression)
- [`TSNonNullExpression`](#tsnonnullexpression)
- [`TSSatisfiesExpression`](#tssatisfiesexpression)
- [`TSTypeAssertion`](#tstypeassertion)
- [`TaggedTemplateExpression`](#taggedtemplateexpression)
- [`TemplateLiteral`](#templateliteral)
- [`ThisExpression`](#thisexpression)
- [`TopicReference`](#topicreference)
- [`TupleExpression`](#tupleexpression)
- [`TypeCastExpression`](#typecastexpression)
- [`UnaryExpression`](#unaryexpression)
- [`UpdateExpression`](#updateexpression)
- [`YieldExpression`](#yieldexpression)

#### ExpressionWrapper

A wrapper of expression that does not have runtime semantics.
```js title="JavaScript"
t.isExpressionWrapper(node);
```

Covered nodes:
- [`ExpressionStatement`](#expressionstatement)
- [`ParenthesizedExpression`](#parenthesizedexpression)
- [`TypeCastExpression`](#typecastexpression)

#### Flow

A cover of AST nodes defined for Flow.
```js title="JavaScript"
t.isFlow(node);
```

Covered nodes:
- [`AnyTypeAnnotation`](#anytypeannotation)
- [`ArrayTypeAnnotation`](#arraytypeannotation)
- [`BooleanLiteralTypeAnnotation`](#booleanliteraltypeannotation)
- [`BooleanTypeAnnotation`](#booleantypeannotation)
- [`ClassImplements`](#classimplements)
- [`DeclareClass`](#declareclass)
- [`DeclareExportAllDeclaration`](#declareexportalldeclaration)
- [`DeclareExportDeclaration`](#declareexportdeclaration)
- [`DeclareFunction`](#declarefunction)
- [`DeclareInterface`](#declareinterface)
- [`DeclareModule`](#declaremodule)
- [`DeclareModuleExports`](#declaremoduleexports)
- [`DeclareOpaqueType`](#declareopaquetype)
- [`DeclareTypeAlias`](#declaretypealias)
- [`DeclareVariable`](#declarevariable)
- [`DeclaredPredicate`](#declaredpredicate)
- [`EmptyTypeAnnotation`](#emptytypeannotation)
- [`EnumBooleanBody`](#enumbooleanbody)
- [`EnumBooleanMember`](#enumbooleanmember)
- [`EnumDeclaration`](#enumdeclaration)
- [`EnumDefaultedMember`](#enumdefaultedmember)
- [`EnumNumberBody`](#enumnumberbody)
- [`EnumNumberMember`](#enumnumbermember)
- [`EnumStringBody`](#enumstringbody)
- [`EnumStringMember`](#enumstringmember)
- [`EnumSymbolBody`](#enumsymbolbody)
- [`ExistsTypeAnnotation`](#existstypeannotation)
- [`FunctionTypeAnnotation`](#functiontypeannotation)
- [`FunctionTypeParam`](#functiontypeparam)
- [`GenericTypeAnnotation`](#generictypeannotation)
- [`IndexedAccessType`](#indexedaccesstype)
- [`InferredPredicate`](#inferredpredicate)
- [`InterfaceDeclaration`](#interfacedeclaration)
- [`InterfaceExtends`](#interfaceextends)
- [`InterfaceTypeAnnotation`](#interfacetypeannotation)
- [`IntersectionTypeAnnotation`](#intersectiontypeannotation)
- [`MixedTypeAnnotation`](#mixedtypeannotation)
- [`NullLiteralTypeAnnotation`](#nullliteraltypeannotation)
- [`NullableTypeAnnotation`](#nullabletypeannotation)
- [`NumberLiteralTypeAnnotation`](#numberliteraltypeannotation)
- [`NumberTypeAnnotation`](#numbertypeannotation)
- [`ObjectTypeAnnotation`](#objecttypeannotation)
- [`ObjectTypeCallProperty`](#objecttypecallproperty)
- [`ObjectTypeIndexer`](#objecttypeindexer)
- [`ObjectTypeInternalSlot`](#objecttypeinternalslot)
- [`ObjectTypeProperty`](#objecttypeproperty)
- [`ObjectTypeSpreadProperty`](#objecttypespreadproperty)
- [`OpaqueType`](#opaquetype)
- [`OptionalIndexedAccessType`](#optionalindexedaccesstype)
- [`QualifiedTypeIdentifier`](#qualifiedtypeidentifier)
- [`StringLiteralTypeAnnotation`](#stringliteraltypeannotation)
- [`StringTypeAnnotation`](#stringtypeannotation)
- [`SymbolTypeAnnotation`](#symboltypeannotation)
- [`ThisTypeAnnotation`](#thistypeannotation)
- [`TupleTypeAnnotation`](#tupletypeannotation)
- [`TypeAlias`](#typealias)
- [`TypeAnnotation`](#typeannotation)
- [`TypeCastExpression`](#typecastexpression)
- [`TypeParameter`](#typeparameter)
- [`TypeParameterDeclaration`](#typeparameterdeclaration)
- [`TypeParameterInstantiation`](#typeparameterinstantiation)
- [`TypeofTypeAnnotation`](#typeoftypeannotation)
- [`UnionTypeAnnotation`](#uniontypeannotation)
- [`Variance`](#variance)
- [`VoidTypeAnnotation`](#voidtypeannotation)

#### FlowBaseAnnotation

A cover of primary Flow type annotations.
```js title="JavaScript"
t.isFlowBaseAnnotation(node);
```

Covered nodes:
- [`AnyTypeAnnotation`](#anytypeannotation)
- [`BooleanTypeAnnotation`](#booleantypeannotation)
- [`EmptyTypeAnnotation`](#emptytypeannotation)
- [`MixedTypeAnnotation`](#mixedtypeannotation)
- [`NullLiteralTypeAnnotation`](#nullliteraltypeannotation)
- [`NumberTypeAnnotation`](#numbertypeannotation)
- [`StringTypeAnnotation`](#stringtypeannotation)
- [`SymbolTypeAnnotation`](#symboltypeannotation)
- [`ThisTypeAnnotation`](#thistypeannotation)
- [`VoidTypeAnnotation`](#voidtypeannotation)

#### FlowDeclaration

A cover of Flow declarations.
```js title="JavaScript"
t.isFlowDeclaration(node);
```

Covered nodes:
- [`DeclareClass`](#declareclass)
- [`DeclareExportAllDeclaration`](#declareexportalldeclaration)
- [`DeclareExportDeclaration`](#declareexportdeclaration)
- [`DeclareFunction`](#declarefunction)
- [`DeclareInterface`](#declareinterface)
- [`DeclareModule`](#declaremodule)
- [`DeclareModuleExports`](#declaremoduleexports)
- [`DeclareOpaqueType`](#declareopaquetype)
- [`DeclareTypeAlias`](#declaretypealias)
- [`DeclareVariable`](#declarevariable)
- [`InterfaceDeclaration`](#interfacedeclaration)
- [`OpaqueType`](#opaquetype)
- [`TypeAlias`](#typealias)

#### FlowPredicate

A cover of Flow predicates.
```js title="JavaScript"
t.isFlowPredicate(node);
```

Covered nodes:
- [`DeclaredPredicate`](#declaredpredicate)
- [`InferredPredicate`](#inferredpredicate)

#### FlowType

A cover of Flow type annotations.
```js title="JavaScript"
t.isFlowType(node);
```

Covered nodes:
- [`AnyTypeAnnotation`](#anytypeannotation)
- [`ArrayTypeAnnotation`](#arraytypeannotation)
- [`BooleanLiteralTypeAnnotation`](#booleanliteraltypeannotation)
- [`BooleanTypeAnnotation`](#booleantypeannotation)
- [`EmptyTypeAnnotation`](#emptytypeannotation)
- [`ExistsTypeAnnotation`](#existstypeannotation)
- [`FunctionTypeAnnotation`](#functiontypeannotation)
- [`GenericTypeAnnotation`](#generictypeannotation)
- [`IndexedAccessType`](#indexedaccesstype)
- [`InterfaceTypeAnnotation`](#interfacetypeannotation)
- [`IntersectionTypeAnnotation`](#intersectiontypeannotation)
- [`MixedTypeAnnotation`](#mixedtypeannotation)
- [`NullLiteralTypeAnnotation`](#nullliteraltypeannotation)
- [`NullableTypeAnnotation`](#nullabletypeannotation)
- [`NumberLiteralTypeAnnotation`](#numberliteraltypeannotation)
- [`NumberTypeAnnotation`](#numbertypeannotation)
- [`ObjectTypeAnnotation`](#objecttypeannotation)
- [`OptionalIndexedAccessType`](#optionalindexedaccesstype)
- [`StringLiteralTypeAnnotation`](#stringliteraltypeannotation)
- [`StringTypeAnnotation`](#stringtypeannotation)
- [`SymbolTypeAnnotation`](#symboltypeannotation)
- [`ThisTypeAnnotation`](#thistypeannotation)
- [`TupleTypeAnnotation`](#tupletypeannotation)
- [`TypeofTypeAnnotation`](#typeoftypeannotation)
- [`UnionTypeAnnotation`](#uniontypeannotation)
- [`VoidTypeAnnotation`](#voidtypeannotation)

#### For

A cover of [ForStatement](https://tc39.es/ecma262/#sec-for-statement)s and [ForXStatement](#forxstatement)s.
```js title="JavaScript"
t.isFor(node);
```

Covered nodes:
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)
- [`ForStatement`](#forstatement)

#### ForXStatement

A cover of [ForInStatements and ForOfStatements](https://tc39.es/ecma262/#sec-for-in-and-for-of-statements).
```js title="JavaScript"
t.isForXStatement(node);
```

Covered nodes:
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)

#### Function

A cover of functions and [method](#method)s, the must have `body` and `params`. Note: `Function` is different to `FunctionParent`. For example, a `StaticBlock` is a `FunctionParent` but not `Function`.
```js title="JavaScript"
t.isFunction(node);
```

Covered nodes:
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`ClassMethod`](#classmethod)
- [`ClassPrivateMethod`](#classprivatemethod)
- [`FunctionDeclaration`](#functiondeclaration)
- [`FunctionExpression`](#functionexpression)
- [`ObjectMethod`](#objectmethod)

#### FunctionParent

A cover of AST nodes that start an execution context with new [VariableEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `var` declarations. FunctionParent did not include `Program` since Babel 7.
```js title="JavaScript"
t.isFunctionParent(node);
```

Covered nodes:
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`ClassMethod`](#classmethod)
- [`ClassPrivateMethod`](#classprivatemethod)
- [`FunctionDeclaration`](#functiondeclaration)
- [`FunctionExpression`](#functionexpression)
- [`ObjectMethod`](#objectmethod)
- [`StaticBlock`](#staticblock)
- [`TSModuleBlock`](#tsmoduleblock)

#### Immutable

A cover of immutable objects and JSX elements. An object is [immutable](https://tc39.es/ecma262/#immutable-prototype-exotic-object) if no other properties can be defined once created.
```js title="JavaScript"
t.isImmutable(node);
```

Covered nodes:
- [`BigIntLiteral`](#bigintliteral)
- [`BooleanLiteral`](#booleanliteral)
- [`DecimalLiteral`](#decimalliteral)
- [`JSXAttribute`](#jsxattribute)
- [`JSXClosingElement`](#jsxclosingelement)
- [`JSXClosingFragment`](#jsxclosingfragment)
- [`JSXElement`](#jsxelement)
- [`JSXExpressionContainer`](#jsxexpressioncontainer)
- [`JSXFragment`](#jsxfragment)
- [`JSXOpeningElement`](#jsxopeningelement)
- [`JSXOpeningFragment`](#jsxopeningfragment)
- [`JSXSpreadChild`](#jsxspreadchild)
- [`JSXText`](#jsxtext)
- [`NullLiteral`](#nullliteral)
- [`NumericLiteral`](#numericliteral)
- [`StringLiteral`](#stringliteral)

#### ImportOrExportDeclaration

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.21.0` | Introduced |
</details>

A cover of ImportDeclaration and [ExportDeclaration](#exportdeclaration).
```js title="JavaScript"
t.isImportOrExportDeclaration(node);
```

Covered nodes:
- [`ExportAllDeclaration`](#exportalldeclaration)
- [`ExportDefaultDeclaration`](#exportdefaultdeclaration)
- [`ExportNamedDeclaration`](#exportnameddeclaration)
- [`ImportDeclaration`](#importdeclaration)

#### JSX

A cover of AST nodes defined for [JSX](https://facebook.github.io/jsx/).
```js title="JavaScript"
t.isJSX(node);
```

Covered nodes:
- [`JSXAttribute`](#jsxattribute)
- [`JSXClosingElement`](#jsxclosingelement)
- [`JSXClosingFragment`](#jsxclosingfragment)
- [`JSXElement`](#jsxelement)
- [`JSXEmptyExpression`](#jsxemptyexpression)
- [`JSXExpressionContainer`](#jsxexpressioncontainer)
- [`JSXFragment`](#jsxfragment)
- [`JSXIdentifier`](#jsxidentifier)
- [`JSXMemberExpression`](#jsxmemberexpression)
- [`JSXNamespacedName`](#jsxnamespacedname)
- [`JSXOpeningElement`](#jsxopeningelement)
- [`JSXOpeningFragment`](#jsxopeningfragment)
- [`JSXSpreadAttribute`](#jsxspreadattribute)
- [`JSXSpreadChild`](#jsxspreadchild)
- [`JSXText`](#jsxtext)

#### LVal

A cover of left hand side expressions used in the `left` of assignment expressions and [ForXStatement](#forxstatement)s.
```js title="JavaScript"
t.isLVal(node);
```

Covered nodes:
- [`ArrayPattern`](#arraypattern)
- [`AssignmentPattern`](#assignmentpattern)
- [`Identifier`](#identifier)
- [`MemberExpression`](#memberexpression)
- [`ObjectPattern`](#objectpattern)
- [`RestElement`](#restelement)
- [`TSAsExpression`](#tsasexpression)
- [`TSNonNullExpression`](#tsnonnullexpression)
- [`TSParameterProperty`](#tsparameterproperty)
- [`TSSatisfiesExpression`](#tssatisfiesexpression)
- [`TSTypeAssertion`](#tstypeassertion)

#### Literal

A cover of [Literal](https://tc39.es/ecma262/#sec-primary-expression-literals)s, [Regular Expression Literal](https://tc39.es/ecma262/#sec-primary-expression-regular-expression-literals)s and [Template Literal](https://tc39.es/ecma262/#sec-template-literals)s.
```js title="JavaScript"
t.isLiteral(node);
```

Covered nodes:
- [`BigIntLiteral`](#bigintliteral)
- [`BooleanLiteral`](#booleanliteral)
- [`DecimalLiteral`](#decimalliteral)
- [`NullLiteral`](#nullliteral)
- [`NumericLiteral`](#numericliteral)
- [`RegExpLiteral`](#regexpliteral)
- [`StringLiteral`](#stringliteral)
- [`TemplateLiteral`](#templateliteral)

#### Loop

A cover of loop statements.
```js title="JavaScript"
t.isLoop(node);
```

Covered nodes:
- [`DoWhileStatement`](#dowhilestatement)
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)
- [`ForStatement`](#forstatement)
- [`WhileStatement`](#whilestatement)

#### Method

A cover of object methods and class methods.
```js title="JavaScript"
t.isMethod(node);
```

Covered nodes:
- [`ClassMethod`](#classmethod)
- [`ClassPrivateMethod`](#classprivatemethod)
- [`ObjectMethod`](#objectmethod)

#### Miscellaneous

A cover of non-standard AST types that are sometimes useful for development.
```js title="JavaScript"
t.isMiscellaneous(node);
```

Covered nodes:
- [`Noop`](#noop)
- [`Placeholder`](#placeholder)
- [`V8IntrinsicIdentifier`](#v8intrinsicidentifier)

#### ModuleDeclaration

<details>
  <summary>History</summary>

| Version | Changes |
| --- | --- |
| `v7.21.0` | Deprecated |
</details>

:::caution

Deprecated, use [`ImportOrExportDeclaration`](#importorexportdeclaration) instead. Check out [PR #15266](https://github.com/babel/babel/pull/15266#issue-1492649843) for migration notes.

:::
```js title="JavaScript"
t.isModuleDeclaration(node);
```

Covered nodes:
- [`ExportAllDeclaration`](#exportalldeclaration)
- [`ExportDefaultDeclaration`](#exportdefaultdeclaration)
- [`ExportNamedDeclaration`](#exportnameddeclaration)
- [`ImportDeclaration`](#importdeclaration)

#### ModuleSpecifier

A cover of import and export specifiers. Note: It is _not_ the [ModuleSpecifier](https://tc39.es/ecma262/#prod-ModuleSpecifier) defined in the spec.
```js title="JavaScript"
t.isModuleSpecifier(node);
```

Covered nodes:
- [`ExportDefaultSpecifier`](#exportdefaultspecifier)
- [`ExportNamespaceSpecifier`](#exportnamespacespecifier)
- [`ExportSpecifier`](#exportspecifier)
- [`ImportDefaultSpecifier`](#importdefaultspecifier)
- [`ImportNamespaceSpecifier`](#importnamespacespecifier)
- [`ImportSpecifier`](#importspecifier)

#### ObjectMember

A cover of [members](https://tc39.es/ecma262/#prod-PropertyDefinitionList) in an object literal.
```js title="JavaScript"
t.isObjectMember(node);
```

Covered nodes:
- [`ObjectMethod`](#objectmethod)
- [`ObjectProperty`](#objectproperty)

#### Pattern

A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern) except Identifiers.
```js title="JavaScript"
t.isPattern(node);
```

Covered nodes:
- [`ArrayPattern`](#arraypattern)
- [`AssignmentPattern`](#assignmentpattern)
- [`ObjectPattern`](#objectpattern)

#### PatternLike

A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern)s.
```js title="JavaScript"
t.isPatternLike(node);
```

Covered nodes:
- [`ArrayPattern`](#arraypattern)
- [`AssignmentPattern`](#assignmentpattern)
- [`Identifier`](#identifier)
- [`ObjectPattern`](#objectpattern)
- [`RestElement`](#restelement)
- [`TSAsExpression`](#tsasexpression)
- [`TSNonNullExpression`](#tsnonnullexpression)
- [`TSSatisfiesExpression`](#tssatisfiesexpression)
- [`TSTypeAssertion`](#tstypeassertion)

#### Private

A cover of private class elements and private identifiers.
```js title="JavaScript"
t.isPrivate(node);
```

Covered nodes:
- [`ClassPrivateMethod`](#classprivatemethod)
- [`ClassPrivateProperty`](#classprivateproperty)
- [`PrivateName`](#privatename)

#### Property

A cover of object properties and class properties.
```js title="JavaScript"
t.isProperty(node);
```

Covered nodes:
- [`ClassAccessorProperty`](#classaccessorproperty)
- [`ClassPrivateProperty`](#classprivateproperty)
- [`ClassProperty`](#classproperty)
- [`ObjectProperty`](#objectproperty)

#### Pureish

A cover of AST nodes which do not have side-effects. In other words, there is no observable behaviour changes if they are evaluated more than once.
```js title="JavaScript"
t.isPureish(node);
```

Covered nodes:
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`BigIntLiteral`](#bigintliteral)
- [`BooleanLiteral`](#booleanliteral)
- [`DecimalLiteral`](#decimalliteral)
- [`FunctionDeclaration`](#functiondeclaration)
- [`FunctionExpression`](#functionexpression)
- [`NullLiteral`](#nullliteral)
- [`NumericLiteral`](#numericliteral)
- [`RegExpLiteral`](#regexpliteral)
- [`StringLiteral`](#stringliteral)

#### Scopable

A cover of [FunctionParent](#functionparent) and [BlockParent](#blockparent).
```js title="JavaScript"
t.isScopable(node);
```

Covered nodes:
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`BlockStatement`](#blockstatement)
- [`CatchClause`](#catchclause)
- [`ClassDeclaration`](#classdeclaration)
- [`ClassExpression`](#classexpression)
- [`ClassMethod`](#classmethod)
- [`ClassPrivateMethod`](#classprivatemethod)
- [`DoWhileStatement`](#dowhilestatement)
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)
- [`ForStatement`](#forstatement)
- [`FunctionDeclaration`](#functiondeclaration)
- [`FunctionExpression`](#functionexpression)
- [`ObjectMethod`](#objectmethod)
- [`Program`](#program)
- [`StaticBlock`](#staticblock)
- [`SwitchStatement`](#switchstatement)
- [`TSModuleBlock`](#tsmoduleblock)
- [`WhileStatement`](#whilestatement)

#### Standardized

A cover of AST nodes which are part of an official ECMAScript specification.
```js title="JavaScript"
t.isStandardized(node);
```

Covered nodes:
- [`ArrayExpression`](#arrayexpression)
- [`ArrayPattern`](#arraypattern)
- [`ArrowFunctionExpression`](#arrowfunctionexpression)
- [`AssignmentExpression`](#assignmentexpression)
- [`AssignmentPattern`](#assignmentpattern)
- [`AwaitExpression`](#awaitexpression)
- [`BigIntLiteral`](#bigintliteral)
- [`BinaryExpression`](#binaryexpression)
- [`BlockStatement`](#blockstatement)
- [`BooleanLiteral`](#booleanliteral)
- [`BreakStatement`](#breakstatement)
- [`CallExpression`](#callexpression)
- [`CatchClause`](#catchclause)
- [`ClassAccessorProperty`](#classaccessorproperty)
- [`ClassBody`](#classbody)
- [`ClassDeclaration`](#classdeclaration)
- [`ClassExpression`](#classexpression)
- [`ClassMethod`](#classmethod)
- [`ClassPrivateMethod`](#classprivatemethod)
- [`ClassPrivateProperty`](#classprivateproperty)
- [`ClassProperty`](#classproperty)
- [`ConditionalExpression`](#conditionalexpression)
- [`ContinueStatement`](#continuestatement)
- [`DebuggerStatement`](#debuggerstatement)
- [`Directive`](#directive)
- [`DirectiveLiteral`](#directiveliteral)
- [`DoWhileStatement`](#dowhilestatement)
- [`EmptyStatement`](#emptystatement)
- [`ExportAllDeclaration`](#exportalldeclaration)
- [`ExportDefaultDeclaration`](#exportdefaultdeclaration)
- [`ExportNamedDeclaration`](#exportnameddeclaration)
- [`ExportNamespaceSpecifier`](#exportnamespacespecifier)
- [`ExportSpecifier`](#exportspecifier)
- [`ExpressionStatement`](#expressionstatement)
- [`File`](#file)
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)
- [`ForStatement`](#forstatement)
- [`FunctionDeclaration`](#functiondeclaration)
- [`FunctionExpression`](#functionexpression)
- [`Identifier`](#identifier)
- [`IfStatement`](#ifstatement)
- [`Import`](#import)
- [`ImportDeclaration`](#importdeclaration)
- [`ImportDefaultSpecifier`](#importdefaultspecifier)
- [`ImportExpression`](#importexpression)
- [`ImportNamespaceSpecifier`](#importnamespacespecifier)
- [`ImportSpecifier`](#importspecifier)
- [`InterpreterDirective`](#interpreterdirective)
- [`LabeledStatement`](#labeledstatement)
- [`LogicalExpression`](#logicalexpression)
- [`MemberExpression`](#memberexpression)
- [`MetaProperty`](#metaproperty)
- [`NewExpression`](#newexpression)
- [`NullLiteral`](#nullliteral)
- [`NumericLiteral`](#numericliteral)
- [`ObjectExpression`](#objectexpression)
- [`ObjectMethod`](#objectmethod)
- [`ObjectPattern`](#objectpattern)
- [`ObjectProperty`](#objectproperty)
- [`OptionalCallExpression`](#optionalcallexpression)
- [`OptionalMemberExpression`](#optionalmemberexpression)
- [`ParenthesizedExpression`](#parenthesizedexpression)
- [`PrivateName`](#privatename)
- [`Program`](#program)
- [`RegExpLiteral`](#regexpliteral)
- [`RestElement`](#restelement)
- [`ReturnStatement`](#returnstatement)
- [`SequenceExpression`](#sequenceexpression)
- [`SpreadElement`](#spreadelement)
- [`StaticBlock`](#staticblock)
- [`StringLiteral`](#stringliteral)
- [`Super`](#super)
- [`SwitchCase`](#switchcase)
- [`SwitchStatement`](#switchstatement)
- [`TaggedTemplateExpression`](#taggedtemplateexpression)
- [`TemplateElement`](#templateelement)
- [`TemplateLiteral`](#templateliteral)
- [`ThisExpression`](#thisexpression)
- [`ThrowStatement`](#throwstatement)
- [`TryStatement`](#trystatement)
- [`UnaryExpression`](#unaryexpression)
- [`UpdateExpression`](#updateexpression)
- [`VariableDeclaration`](#variabledeclaration)
- [`VariableDeclarator`](#variabledeclarator)
- [`WhileStatement`](#whilestatement)
- [`WithStatement`](#withstatement)
- [`YieldExpression`](#yieldexpression)

#### Statement

A cover of any [Statement](https://tc39.es/ecma262/#prod-Statement)s.
```js title="JavaScript"
t.isStatement(node);
```

Covered nodes:
- [`BlockStatement`](#blockstatement)
- [`BreakStatement`](#breakstatement)
- [`ClassDeclaration`](#classdeclaration)
- [`ContinueStatement`](#continuestatement)
- [`DebuggerStatement`](#debuggerstatement)
- [`DeclareClass`](#declareclass)
- [`DeclareExportAllDeclaration`](#declareexportalldeclaration)
- [`DeclareExportDeclaration`](#declareexportdeclaration)
- [`DeclareFunction`](#declarefunction)
- [`DeclareInterface`](#declareinterface)
- [`DeclareModule`](#declaremodule)
- [`DeclareModuleExports`](#declaremoduleexports)
- [`DeclareOpaqueType`](#declareopaquetype)
- [`DeclareTypeAlias`](#declaretypealias)
- [`DeclareVariable`](#declarevariable)
- [`DoWhileStatement`](#dowhilestatement)
- [`EmptyStatement`](#emptystatement)
- [`EnumDeclaration`](#enumdeclaration)
- [`ExportAllDeclaration`](#exportalldeclaration)
- [`ExportDefaultDeclaration`](#exportdefaultdeclaration)
- [`ExportNamedDeclaration`](#exportnameddeclaration)
- [`ExpressionStatement`](#expressionstatement)
- [`ForInStatement`](#forinstatement)
- [`ForOfStatement`](#forofstatement)
- [`ForStatement`](#forstatement)
- [`FunctionDeclaration`](#functiondeclaration)
- [`IfStatement`](#ifstatement)
- [`ImportDeclaration`](#importdeclaration)
- [`InterfaceDeclaration`](#interfacedeclaration)
- [`LabeledStatement`](#labeledstatement)
- [`OpaqueType`](#opaquetype)
- [`ReturnStatement`](#returnstatement)
- [`SwitchStatement`](#switchstatement)
- [`TSDeclareFunction`](#tsdeclarefunction)
- [`TSEnumDeclaration`](#tsenumdeclaration)
- [`TSExportAssignment`](#tsexportassignment)
- [`TSImportEqualsDeclaration`](#tsimportequalsdeclaration)
- [`TSInterfaceDeclaration`](#tsinterfacedeclaration)
- [`TSModuleDeclaration`](#tsmoduledeclaration)
- [`TSNamespaceExportDeclaration`](#tsnamespaceexportdeclaration)
- [`TSTypeAliasDeclaration`](#tstypealiasdeclaration)
- [`ThrowStatement`](#throwstatement)
- [`TryStatement`](#trystatement)
- [`TypeAlias`](#typealias)
- [`VariableDeclaration`](#variabledeclaration)
- [`WhileStatement`](#whilestatement)
- [`WithStatement`](#withstatement)

#### TSBaseType

A cover of primary TypeScript type annotations.
```js title="JavaScript"
t.isTSBaseType(node);
```

Covered nodes:
- [`TSAnyKeyword`](#tsanykeyword)
- [`TSBigIntKeyword`](#tsbigintkeyword)
- [`TSBooleanKeyword`](#tsbooleankeyword)
- [`TSIntrinsicKeyword`](#tsintrinsickeyword)
- [`TSLiteralType`](#tsliteraltype)
- [`TSNeverKeyword`](#tsneverkeyword)
- [`TSNullKeyword`](#tsnullkeyword)
- [`TSNumberKeyword`](#tsnumberkeyword)
- [`TSObjectKeyword`](#tsobjectkeyword)
- [`TSStringKeyword`](#tsstringkeyword)
- [`TSSymbolKeyword`](#tssymbolkeyword)
- [`TSThisType`](#tsthistype)
- [`TSUndefinedKeyword`](#tsundefinedkeyword)
- [`TSUnknownKeyword`](#tsunknownkeyword)
- [`TSVoidKeyword`](#tsvoidkeyword)

#### TSEntityName

A cover of ts entities.
```js title="JavaScript"
t.isTSEntityName(node);
```

Covered nodes:
- [`Identifier`](#identifier)
- [`TSQualifiedName`](#tsqualifiedname)

#### TSType

A cover of TypeScript type annotations.
```js title="JavaScript"
t.isTSType(node);
```

Covered nodes:
- [`TSAnyKeyword`](#tsanykeyword)
- [`TSArrayType`](#tsarraytype)
- [`TSBigIntKeyword`](#tsbigintkeyword)
- [`TSBooleanKeyword`](#tsbooleankeyword)
- [`TSConditionalType`](#tsconditionaltype)
- [`TSConstructorType`](#tsconstructortype)
- [`TSExpressionWithTypeArguments`](#tsexpressionwithtypearguments)
- [`TSFunctionType`](#tsfunctiontype)
- [`TSImportType`](#tsimporttype)
- [`TSIndexedAccessType`](#tsindexedaccesstype)
- [`TSInferType`](#tsinfertype)
- [`TSIntersectionType`](#tsintersectiontype)
- [`TSIntrinsicKeyword`](#tsintrinsickeyword)
- [`TSLiteralType`](#tsliteraltype)
- [`TSMappedType`](#tsmappedtype)
- [`TSNeverKeyword`](#tsneverkeyword)
- [`TSNullKeyword`](#tsnullkeyword)
- [`TSNumberKeyword`](#tsnumberkeyword)
- [`TSObjectKeyword`](#tsobjectkeyword)
- [`TSOptionalType`](#tsoptionaltype)
- [`TSParenthesizedType`](#tsparenthesizedtype)
- [`TSRestType`](#tsresttype)
- [`TSStringKeyword`](#tsstringkeyword)
- [`TSSymbolKeyword`](#tssymbolkeyword)
- [`TSThisType`](#tsthistype)
- [`TSTupleType`](#tstupletype)
- [`TSTypeLiteral`](#tstypeliteral)
- [`TSTypeOperator`](#tstypeoperator)
- [`TSTypePredicate`](#tstypepredicate)
- [`TSTypeQuery`](#tstypequery)
- [`TSTypeReference`](#tstypereference)
- [`TSUndefinedKeyword`](#tsundefinedkeyword)
- [`TSUnionType`](#tsuniontype)
- [`TSUnknownKeyword`](#tsunknownkeyword)
- [`TSVoidKeyword`](#tsvoidkeyword)

#### TSTypeElement

A cover of TypeScript type declarations.
```js title="JavaScript"
t.isTSTypeElement(node);
```

Covered nodes:
- [`TSCallSignatureDeclaration`](#tscallsignaturedeclaration)
- [`TSConstructSignatureDeclaration`](#tsconstructsignaturedeclaration)
- [`TSIndexSignature`](#tsindexsignature)
- [`TSMethodSignature`](#tsmethodsignature)
- [`TSPropertySignature`](#tspropertysignature)

#### Terminatorless

A cover of AST nodes whose semantic will change when a line terminator is inserted between the operator and the operand.
```js title="JavaScript"
t.isTerminatorless(node);
```

Covered nodes:
- [`AwaitExpression`](#awaitexpression)
- [`BreakStatement`](#breakstatement)
- [`ContinueStatement`](#continuestatement)
- [`ReturnStatement`](#returnstatement)
- [`ThrowStatement`](#throwstatement)
- [`YieldExpression`](#yieldexpression)

#### TypeScript

A cover of AST nodes defined for TypeScript.
```js title="JavaScript"
t.isTypeScript(node);
```

Covered nodes:
- [`TSAnyKeyword`](#tsanykeyword)
- [`TSArrayType`](#tsarraytype)
- [`TSAsExpression`](#tsasexpression)
- [`TSBigIntKeyword`](#tsbigintkeyword)
- [`TSBooleanKeyword`](#tsbooleankeyword)
- [`TSCallSignatureDeclaration`](#tscallsignaturedeclaration)
- [`TSConditionalType`](#tsconditionaltype)
- [`TSConstructSignatureDeclaration`](#tsconstructsignaturedeclaration)
- [`TSConstructorType`](#tsconstructortype)
- [`TSDeclareFunction`](#tsdeclarefunction)
- [`TSDeclareMethod`](#tsdeclaremethod)
- [`TSEnumDeclaration`](#tsenumdeclaration)
- [`TSEnumMember`](#tsenummember)
- [`TSExportAssignment`](#tsexportassignment)
- [`TSExpressionWithTypeArguments`](#tsexpressionwithtypearguments)
- [`TSExternalModuleReference`](#tsexternalmodulereference)
- [`TSFunctionType`](#tsfunctiontype)
- [`TSImportEqualsDeclaration`](#tsimportequalsdeclaration)
- [`TSImportType`](#tsimporttype)
- [`TSIndexSignature`](#tsindexsignature)
- [`TSIndexedAccessType`](#tsindexedaccesstype)
- [`TSInferType`](#tsinfertype)
- [`TSInstantiationExpression`](#tsinstantiationexpression)
- [`TSInterfaceBody`](#tsinterfacebody)
- [`TSInterfaceDeclaration`](#tsinterfacedeclaration)
- [`TSIntersectionType`](#tsintersectiontype)
- [`TSIntrinsicKeyword`](#tsintrinsickeyword)
- [`TSLiteralType`](#tsliteraltype)
- [`TSMappedType`](#tsmappedtype)
- [`TSMethodSignature`](#tsmethodsignature)
- [`TSModuleBlock`](#tsmoduleblock)
- [`TSModuleDeclaration`](#tsmoduledeclaration)
- [`TSNamedTupleMember`](#tsnamedtuplemember)
- [`TSNamespaceExportDeclaration`](#tsnamespaceexportdeclaration)
- [`TSNeverKeyword`](#tsneverkeyword)
- [`TSNonNullExpression`](#tsnonnullexpression)
- [`TSNullKeyword`](#tsnullkeyword)
- [`TSNumberKeyword`](#tsnumberkeyword)
- [`TSObjectKeyword`](#tsobjectkeyword)
- [`TSOptionalType`](#tsoptionaltype)
- [`TSParameterProperty`](#tsparameterproperty)
- [`TSParenthesizedType`](#tsparenthesizedtype)
- [`TSPropertySignature`](#tspropertysignature)
- [`TSQualifiedName`](#tsqualifiedname)
- [`TSRestType`](#tsresttype)
- [`TSSatisfiesExpression`](#tssatisfiesexpression)
- [`TSStringKeyword`](#tsstringkeyword)
- [`TSSymbolKeyword`](#tssymbolkeyword)
- [`TSThisType`](#tsthistype)
- [`TSTupleType`](#tstupletype)
- [`TSTypeAliasDeclaration`](#tstypealiasdeclaration)
- [`TSTypeAnnotation`](#tstypeannotation)
- [`TSTypeAssertion`](#tstypeassertion)
- [`TSTypeLiteral`](#tstypeliteral)
- [`TSTypeOperator`](#tstypeoperator)
- [`TSTypeParameter`](#tstypeparameter)
- [`TSTypeParameterDeclaration`](#tstypeparameterdeclaration)
- [`TSTypeParameterInstantiation`](#tstypeparameterinstantiation)
- [`TSTypePredicate`](#tstypepredicate)
- [`TSTypeQuery`](#tstypequery)
- [`TSTypeReference`](#tstypereference)
- [`TSUndefinedKeyword`](#tsundefinedkeyword)
- [`TSUnionType`](#tsuniontype)
- [`TSUnknownKeyword`](#tsunknownkeyword)
- [`TSVoidKeyword`](#tsvoidkeyword)

#### UnaryLike

A cover of UnaryExpression and SpreadElement.
```js title="JavaScript"
t.isUnaryLike(node);
```

Covered nodes:
- [`SpreadElement`](#spreadelement)
- [`UnaryExpression`](#unaryexpression)

#### UserWhitespacable

Deprecated. Will be removed in Babel 8.
```js title="JavaScript"
t.isUserWhitespacable(node);
```

Covered nodes:
- [`ObjectMethod`](#objectmethod)
- [`ObjectProperty`](#objectproperty)
- [`ObjectTypeCallProperty`](#objecttypecallproperty)
- [`ObjectTypeIndexer`](#objecttypeindexer)
- [`ObjectTypeInternalSlot`](#objecttypeinternalslot)
- [`ObjectTypeProperty`](#objecttypeproperty)
- [`ObjectTypeSpreadProperty`](#objecttypespreadproperty)

#### While

A cover of DoWhileStatement and WhileStatement, which share the same AST shape.
```js title="JavaScript"
t.isWhile(node);
```

Covered nodes:
- [`DoWhileStatement`](#dowhilestatement)
- [`WhileStatement`](#whilestatement)
